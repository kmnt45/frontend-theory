# JavaScript

## 1. Что такое ECMAScript? В чём отличие от JavaScript?

`ECMAScript` — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.

Что было добавлено в ES6:

- Стрелочные функции и интерполяция в строках
- Ключевое слово const
- Блочная видимость
- Параметры по умолчанию
- Классы и наследование
- Оператор for-of для перебора итерируемых объектов в цикле
- spread и rest операторы
- Promises
- Модули

## 2. Типы данных?

Примитивы хранятся непосредственно по значению:

- `number` — для чисел (целые и с плавающей точкой).

- `string` — для строк.

- `boolean` — логический тип (true / false).

- `undefined` — значение по умолчанию для:
  - переменной, которой не было присвоено значение;
  - функции, которая ничего не возвращает явно, например, console.log(1);
  - несуществующего свойства объекта.

- `null` — значение, которое присваивается переменной явно.

  При сравнении null и undefined мы получаем true, когда используем оператор ==, и false при использовании оператора ===.

- `symbol` — уникальные идентификаторы.
  ```javascript
  const sym1 = Symbol();
  const sym2 = Symbol();
  console.log(sym1 === sym2); // false
  ```
  
  Символы часто используют для создания скрытых свойств объектов. Они не отображаются в for...in и не конфликтуют с другими ключами.
  Также есть well-known symbols, например Symbol.iterator, который определяет поведение объектов при итерации (for...of, спред и т.д.).

- `bigint` — для целых чисел произвольной длины.
  ```javascript
  const big = BigInt(12345678901234567890n);
  ```

Объекты хранятся по ссылке и могут содержать множество значений и методов:

- `object` — для коллекций данных и более сложных структур.

## 3. Разница между let, const и var?

`var`
- Поднимается в начало области видимости при компиляции (имеет область видимости функции).
- Можно перезаписать и переопределить.

`let`
- Поднимается в начало области видимости при компиляции, но находится в TDZ до момента инициализации (имеет блочную область видимости).
- Можно перезаписать, но нельзя переопределить.

`const`
- Поднимается в начало области видимости при компиляции, но находится в TDZ до момента инициализации (имеет блочную область видимости).
- Нельзя перезаписать и нельзя переопределить.

## 4. Что такое временная мёртвая зона (temporal dead zone)?

`Временная мёртвая зона (temporal dead zone)` — это период времени между началом области видимости, где объявлена переменная с `let` или `const`, и
моментом, когда эта переменная инициализирована. В этот период доступ к переменной вызывает ошибку.

## 5. Разница между Rest и Spread операторами?

`Spread оператор (...)` используется для разложения массива или объекта на отдельные элементы или свойства.
Например, `[...arr]` или `{...obj}`.

`Rest оператор (...)` используется для сбора всех оставшихся аргументов функции в массив или свойства объекта в
объект. Например, `function(...args)` или `const {a, ...rest} = obj`.

## 6. Что такое деструктуризация?

`Деструктуризация` — это синтаксическая особенность, позволяющая извлекать значения из массивов или свойств из объектов и
присваивать их переменным. Например, для массива: `const [a, b] = [1, 2]`, для объекта: `const {x, y} = {x: 1, y: 2}`.

## 7. Разница между == и === (нестрогое/строгое равенство)?

`== (нестрогое равенство)` проверяет равенство значений с приведением типов. 

`=== (строгое равенство)` проверяет равенство значений без приведения типов.

## 8. Что такое Strict mode?

`Strict mode (Cтрогий режим)` вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

## 9. Разница между function declaration и function expression?

`Function declaration (объявление функции)`: `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "всплытию".

`Function expression (функциональное выражение)`: `const foo = function() { }` - может быть анонимной или именованной, но доступно только после его объявления.

## 10. Разница между обычными функциями и стрелочными?

`Обычные функции` имеют собственное значение `this`, которое определяется в момент вызова функции. Они также имеют собственную область видимости для `arguments` и могут использоваться с `new`.

`Стрелочные функции` не имеют собственного `this`; вместо этого они захватывают значение `this` из окружающего контекста. Они не имеют `arguments` и не могут использоваться с `new`.

## 11. Что такое генераторы? Когда стоит использовать генераторы?

`Генераторы` — это функции, которые могут приостанавливать выполнение и возобновлять его позже. 
Они полезны для работы с последовательностями данных или асинхронными операциями, когда нужно получать значения по одному шагу за раз.

1. Синтаксис генератора:

   Генератор объявляется с помощью function* (звёздочка после function):

   ```javascript
    function* myGenerator() {
    yield 1;
    yield 2;
    yield 3;
    }
   ```

2. Оператор yield:

   yield приостанавливает выполнение генератора и возвращает значение:

   ```javascript
    const gen = myGenerator();
    
    console.log(gen.next()); // { value: 1, done: false }
    console.log(gen.next()); // { value: 2, done: false }
    console.log(gen.next()); // { value: 3, done: false }
    console.log(gen.next()); // { value: undefined, done: true }
   ```

   Свойства объекта:

   - value — текущее значение.

   - done — флаг завершения генератора.

3. Итерация через for...of

    Генераторы можно использовать как итераторы:

    ```javascript
    for (const value of myGenerator()) {
      console.log(value); // 1, 2, 3
    }
    ```

4. Асинхронные генераторы

   Генераторы могут быть асинхронными с async function* и работать с await:

    ```javascript
    async function* asyncGenerator() {
      yield await new Promise(resolve => setTimeout(() => resolve(1), 1000));
      yield await new Promise(resolve => setTimeout(() => resolve(2), 1000));
    }
    
    (async () => {
      for await (const value of asyncGenerator()) {
        console.log(value); // 1, 2 (с задержкой)
      }
    })();
    ```

## 12. Типы таймеров?

- `setTimeout` выполняет функцию через определённое время.
- `setInterval` выполняет функцию с заданным интервалом.
- `requestAnimationFrame` выполняет функцию перед следующим перерисовкой экрана.

## 13. Контекст выполнения (execution context)?

`Контекст выполнения (Execution Context)` — это среда, в которой выполняется текущий код, и которая управляет областью видимости переменных, определением this и порядком выполнения кода.

Основные типы контекстов выполнения:

1. Глобальный контекст выполнения:
    - Контекст по умолчанию для всего кода.
    - В браузере глобальный объект — window, в Node.js — global.
    - Все глобальные переменные и функции принадлежат этому контексту.

2. Контекст выполнения функции:
    - Создаётся при каждом вызове функции.
    - Внутри функции создаётся локальная область видимости для переменных и функций.
    - Каждый вызов функции — новый контекст выполнения.

Фазы контекста выполнения:

1. Фаза создания (Creation Phase):
- Создаётся объект переменных (Lexical Environment):
    - Все переменные, функции и параметры определяются.
    - Происходит hoisting (подъём).
    - Для функции создаётся псевдомассив arguments.
- Формируется цепочка областей видимости (Scope Chain)
    - Обеспечивает поиск переменных в текущем и внешних контекстах.
- Устанавливается this:
    - В глобальном контексте — глобальный объект.
    - В функции — зависит от способа вызова.

2. Фаза исполнения (Execution Phase, выполнение):
    - Движок выполняет код построчно, используя созданное лексическое окружение и цепочку областей видимости.

## 14. Что такое область видимости (Scope)?

`Область видимости` — это область, ограничивающая доступ к переменным и функциям внутри себя, как бы инкапсулирующая их.

Есть три типа областей видимости:

`Глобальная` — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и
доступны из любого места в коде.

`Функциональная` — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

`Блочная` — переменные, объявленные с помощью ключевых слов let и const, доступны только внутри блока {}, в котором
были
объявлены.

`Область видимости` — это также набор правил, по которым осуществляется поиск переменной. 
Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. 
Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. 
Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. 
Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. 
Это называется цепочкой областей видимости (Scope Chain).

## 15. Что такое поднятие (Hoisting)?

`Поднятие (Hoisting)` - это механизм, при котором объявления переменных и функций "поднимаются" в верхнюю часть их
области видимости во время компиляции.

## 16. Что такое замыкание (Closure)?

`Замыкание` — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости.

## 17. Что обозначает this?

`this` — это ссылка на контекст выполнения функции. Его значение зависит от способа вызова функции, а не от того, где она была определена.

1. В глобальной области видимости

    ```javascript
    console.log(this); // В браузере: window
    ```

2. Внутри метода объекта

    this ссылается на объект, который вызвал метод:

    ```javascript
    const person = {
      name: 'Anton',
      greet() {
        console.log(`Hello, my name is ${this.name}`);
      }
    };
    
    person.greet(); // "Hello, my name is Anton"
    ```

3. В функциях-конструкторах и классах

    this ссылается на создаваемый экземпляр:
    
    ```javascript
    class Person {
      constructor(name) {
        this.name = name;
      }
      greet() {
        console.log(`Hello, my name is ${this.name}`);
      }
    }
    
    const anton = new Person('Anton');
    anton.greet(); // "Hello, my name is Anton"
    ```

4. В обычной функции

   В строгом режиме ('use strict') this будет undefined:

    ```javascript
    function showThis() {
      'use strict';
      console.log(this);
    }
    
    showThis(); // undefined
    ```

    Без строгого режима — глобальный объект (window в браузере).

5. В стрелочных функциях

    this берется из внешнего контекста, где была создана функция:
    
    ```javascript
    const obj = {
      name: 'Anton',
      greet: () => console.log(this.name)
    };
    
    obj.greet(); // undefined, потому что стрелочная функция не имеет собственного this
    
    ```

## 18. Что такое функции высшего порядка (Higher Order Functions)?

`Функция высшего порядка` — это функция, которая либо принимает другие функции в качестве аргументов, либо возвращает функцию.

## 19. Почему в JS функции называют объектами первого класса?

`Функции являются объектами первого класса`, потому что их можно передавать как аргументы, возвращать из других
функций и присваивать переменным.

## 20. Что такое чистая функция?

`Чистая функция` - это функция, которая:

- Всегда возвращает один и тот же результат для одних и тех же аргументов.

- Не имеет побочных эффектов (не изменяет внешние переменные, не взаимодействует с DOM, не делает запросы и т.д.).

## 21. Как превратить любой тип данных в булевый? Перечислите ложные значения?

  Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные
  значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

## 22. Что такое шаблонные литералы (Template Literals)?

`Шаблонные литералы` — это строки, которые могут содержать выражения и многострочные тексты. Они создаются с помощью
обратных кавычек (`` ` ``). Например: `` `Hello, ${name}` ``. Это позволяет легко вставлять переменные и выполнять
выражения в строках.

## 23. Что такое итератор?

`Итератор` — это объект, который умеет последовательно возвращать элементы коллекции и отслеживать своё текущее положение внутри неё.

Итератор должен реализовывать метод next(), который возвращает объект с двумя свойствами:

- value — текущее значение

- done — логическое значение, показывающее, завершена ли итерация (true — итерация завершена)

Чтобы объект был итерируемым (например, для for...of), он должен иметь метод Symbol.iterator.

Пример ручного создания итератора:

```javascript
const iterable = [10, 20, 30];

const iterator = iterable[Symbol.iterator]();

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

Или использование через for...of:

```javascript
for (const value of iterable) {
  console.log(value); // 10, 20, 30
}
```

## 24. Методы объектов?

| Метод                               | Краткое описание                                                                    | Пример                                                                               |
| ----------------------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `Object.keys(obj)`                  | Возвращает массив ключей объекта                                                    | `Object.keys({a:1,b:2}) // ['a','b']`                                                |
| `Object.values(obj)`                | Возвращает массив значений объекта                                                  | `Object.values({a:1,b:2}) // [1,2]`                                                  |
| `Object.entries(obj)`               | Возвращает массив пар `[ключ, значение]`                                            | `Object.entries({a:1,b:2}) // [['a',1],['b',2]]`                                     |
| `Object.assign(target, ...sources)` | Копирует свойства из источников в цель                                              | `Object.assign({a:1},{b:2}) // {a:1,b:2}`                                            |
| `Object.freeze(obj)`                | "Замораживает" объект, запрещает добавлять/изменять/удалять свойства                | `const obj={a:1}; Object.freeze(obj); obj.a=2; console.log(obj.a) // 1`              |
| `Object.seal(obj)`                  | Запечатывает объект, нельзя добавлять/удалять свойства, можно изменять существующие | `const obj={a:1}; Object.seal(obj); obj.a=2; obj.b=3; console.log(obj) // {a:2}`     |
| `Object.create(proto)`              | Создает объект с указанным прототипом                                               | `const proto={g:'hi'}; const obj=Object.create(proto); console.log(obj.g) // 'hi'`   |
| `Object.hasOwnProperty(prop)`       | Проверяет, является ли свойство собственным                                         | `const obj={a:1}; obj.hasOwnProperty('a') // true`                                   |
| `Object.preventExtensions(obj)`     | Запрещает добавлять новые свойства                                                  | `const obj={a:1}; Object.preventExtensions(obj); obj.b=2; console.log(obj) // {a:1}` |
| `Object.isExtensible(obj)`          | Проверяет, можно ли добавлять свойства                                              | `const obj={}; Object.preventExtensions(obj); Object.isExtensible(obj) // false`     |
| `Object.isSealed(obj)`              | Проверяет, запечатан ли объект                                                      | `const obj={a:1}; Object.seal(obj); Object.isSealed(obj) // true`                    |
| `Object.isFrozen(obj)`              | Проверяет, заморожен ли объект                                                      | `const obj={a:1}; Object.freeze(obj); Object.isFrozen(obj) // true`                  |

## 25. Методы строк?

| Метод                               | Описание                                 | Пример                                                       |
| ----------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `length`                            | Длина строки                             | `"Hello".length // 5`                                        |
| `toUpperCase()`                     | Все символы в верхний регистр            | `"hello".toUpperCase() // "HELLO"`                           |
| `toLowerCase()`                     | Все символы в нижний регистр             | `"HELLO".toLowerCase() // "hello"`                           |
| `charAt(index)`                     | Символ по индексу                        | `"JavaScript".charAt(0) // "J"`                              |
| `charCodeAt(index)`                 | Код символа                              | `"A".charCodeAt(0) // 65`                                    |
| `codePointAt(index)`                | Unicode код символа                      | `"𠮷".codePointAt(0) // 134071`                              |
| `includes(substring)`               | Проверка наличия подстроки               | `"Hello".includes("ell") // true`                            |
| `startsWith(substring)`             | Начинается ли с подстроки                | `"Hello".startsWith("He") // true`                           |
| `endsWith(substring)`               | Заканчивается ли подстрокой              | `"Hello".endsWith("lo") // true`                             |
| `indexOf(substring)`                | Индекс первого вхождения                 | `"Hello".indexOf("l") // 2`                                  |
| `lastIndexOf(substring)`            | Индекс последнего вхождения              | `"Hello".lastIndexOf("l") // 3`                              |
| `slice(start, end)`                 | Вырезает часть строки                    | `"Hello".slice(1,4) // "ell"`                                |
| `substring(start, end)`             | Аналог slice, без отрицательных индексов | `"Hello".substring(1,4) // "ell"`                            |
| `substr(start, length)`             | Вырезает подстроку по старту и длине     | `"Hello".substr(1,3) // "ell"`                               |
| `replace(searchValue, newValue)`    | Заменяет подстроку                       | `"Hello".replace("H", "J") // "Jello"`                       |
| `replaceAll(searchValue, newValue)` | Заменяет все вхождения                   | `"aabb".replaceAll("a","x") // "xxbb"`                       |
| `split(separator)`                  | Разбивает на массив                      | `"a,b,c".split(",") // ["a","b","c"]`                        |
| `concat(...strings)`                | Объединяет строки                        | `"Hello".concat(" ","World") // "Hello World"`               |
| `trim()`                            | Удаляет пробелы по краям                 | `"  hi  ".trim() // "hi"`                                    |
| `trimStart()` / `trimLeft()`        | Удаляет пробелы в начале                 | `"  hi".trimStart() // "hi"`                                 |
| `trimEnd()` / `trimRight()`         | Удаляет пробелы в конце                  | `"hi  ".trimEnd() // "hi"`                                   |
| `repeat(count)`                     | Повторяет строку                         | `"Hi!".repeat(3) // "Hi!Hi!Hi!"`                             |
| `localeCompare(str)`                | Сравнение с учётом локали                | `"a".localeCompare("b") // -1`                               |
| `match(regexp)`                     | Возвращает массив совпадений             | `"abc123".match(/\d+/) // ["123"]`                           |
| `matchAll(regexp)`                  | Итератор всех совпадений                 | `[... "abc123def456".matchAll(/\d+/g)] // [["123"],["456"]]` |
| `search(regexp)`                    | Индекс первого совпадения                | `"abc123".search(/\d/) // 3`                                 |
| `padStart(targetLength, padString)` | Дополняет строку слева                   | `"5".padStart(3,"0") // "005"`                               |
| `padEnd(targetLength, padString)`   | Дополняет строку справа                  | `"5".padEnd(3,"0") // "500"`                                 |
| `normalize(form)`                   | Unicode нормализация                     | `"e\u0301".normalize() // "é"`                               |
| `toString()`                        | Преобразует в строку                     | `(123).toString() // "123"`                                  |
| `toLocaleString()`                  | Преобразует с учётом локали              | `(12345).toLocaleString("de-DE") // "12.345"`                |

## 26. Методы массивов? Мутирующие методы массива?

| Метод                                  | Мутирует массив? | Краткое описание                                                 | Пример                                                            |
| -------------------------------------- | ---------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------- |
| `push(...items)`                       | ✅ Да             | Добавляет элементы в конец массива                               | `let arr=[1,2]; arr.push(3); console.log(arr) // [1,2,3]`         |
| `pop()`                                | ✅ Да             | Удаляет последний элемент и возвращает его                       | `let arr=[1,2,3]; arr.pop() // 3`                                 |
| `shift()`                              | ✅ Да             | Удаляет первый элемент и возвращает его                          | `let arr=[1,2,3]; arr.shift() // 1`                               |
| `unshift(...items)`                    | ✅ Да             | Добавляет элементы в начало массива                              | `let arr=[2,3]; arr.unshift(1); console.log(arr) // [1,2,3]`      |
| `splice(start, deleteCount, ...items)` | ✅ Да             | Удаляет/добавляет элементы по индексу                            | `let arr=[1,2,3]; arr.splice(1,1,4); console.log(arr) // [1,4,3]` |
| `sort(compareFn)`                      | ✅ Да             | Сортирует массив на месте                                        | `[3,1,2].sort() // [1,2,3]`                                       |
| `reverse()`                            | ✅ Да             | Переворачивает порядок элементов                                 | `[1,2,3].reverse() // [3,2,1]`                                    |
| `fill(value, start?, end?)`            | ✅ Да             | Заполняет массив значением                                       | `new Array(3).fill(0) // [0,0,0]`                                 |
| `copyWithin(target, start?, end?)`     | ✅ Да             | Копирует часть массива внутри массива                            | `[1,2,3,4].copyWithin(0,2) // [3,4,3,4]`                          |
| `concat(...arrays)`                    | ❌ Нет            | Создает новый массив, объединяя массивы                          | `[1,2].concat([3,4]) // [1,2,3,4]`                                |
| `slice(start?, end?)`                  | ❌ Нет            | Возвращает часть массива в новом массиве                         | `[1,2,3].slice(1,3) // [2,3]`                                     |
| `map(fn)`                              | ❌ Нет            | Применяет функцию к каждому элементу                             | `[1,2,3].map(x=>x*2) // [2,4,6]`                                  |
| `filter(fn)`                           | ❌ Нет            | Возвращает новый массив с элементами, удовлетворяющими условию   | `[1,2,3].filter(x=>x>1) // [2,3]`                                 |
| `reduce(fn, initial)`                  | ❌ Нет            | Вычисляет одно значение на основе элементов                      | `[1,2,3].reduce((a,b)=>a+b,0) // 6`                               |
| `reduceRight(fn, initial)`             | ❌ Нет            | То же самое, но справа налево                                    | `[1,2,3].reduceRight((a,b)=>a-b,0) // 0-3= -3 ...`                |
| `forEach(fn)`                          | ❌ Нет            | Выполняет функцию для каждого элемента                           | `[1,2,3].forEach(x=>console.log(x)) // 1 2 3`                     |
| `find(fn)`                             | ❌ Нет            | Первый элемент, удовлетворяющий условию                          | `[1,2,3].find(x=>x>1) // 2`                                       |
| `findIndex(fn)`                        | ❌ Нет            | Индекс первого элемента, удовлетворяющего условию                | `[1,2,3].findIndex(x=>x>1) // 1`                                  |
| `some(fn)`                             | ❌ Нет            | Проверяет, есть ли хотя бы один элемент, удовлетворяющий условию | `[1,2,3].some(x=>x>2) // true`                                    |
| `every(fn)`                            | ❌ Нет            | Проверяет, все ли элементы удовлетворяют условию                 | `[1,2,3].every(x=>x>0) // true`                                   |
| `includes(value)`                      | ❌ Нет            | Проверяет наличие элемента                                       | `[1,2,3].includes(2) // true`                                     |
| `indexOf(value, fromIndex?)`           | ❌ Нет            | Индекс первого совпадения                                        | `[1,2,3,2].indexOf(2) // 1`                                       |
| `lastIndexOf(value, fromIndex?)`       | ❌ Нет            | Индекс последнего совпадения                                     | `[1,2,3,2].lastIndexOf(2) // 3`                                   |
| `join(separator?)`                     | ❌ Нет            | Преобразует массив в строку                                      | `[1,2,3].join("-") // "1-2-3"`                                    |
| `flat(depth?)`                         | ❌ Нет            | Разворачивает вложенные массивы                                  | `[1,[2,[3]]].flat(2) // [1,2,3]`                                  |
| `flatMap(fn)`                          | ❌ Нет            | map + flat(1)                                                    | `[1,2].flatMap(x=>[x,x*2]) // [1,2,2,4]`                          |
| `toString()`                           | ❌ Нет            | Преобразует массив в строку                                      | `[1,2,3].toString() // "1,2,3"`                                   |
| `toLocaleString()`                     | ❌ Нет            | Преобразует с учётом локали                                      | `[123456].toLocaleString("de-DE") // "123.456"`                   |
| `keys()`                               | ❌ Нет            | Итератор по индексам                                             | `Array.from([1,2].keys()) // [0,1]`                               |
| `values()`                             | ❌ Нет            | Итератор по значениям                                            | `Array.from([1,2].values()) // [1,2]`                             |
| `entries()`                            | ❌ Нет            | Итератор пар [ключ, значение]                                    | `Array.from([1,2].entries()) // [[0,1],[1,2]]`                    |
| `Array.from(iterable)`                 | ❌ Нет            | Новый массив из итерируемого объекта                             | `Array.from("abc") // ["a","b","c"]`                              |
| `Array.isArray(obj)`                   | ❌ Нет            | Проверка, является ли объект массивом                            | `Array.isArray([1,2]) // true`                                    |
| `Array.of(...items)`                   | ❌ Нет            | Новый массив из аргументов                                       | `Array.of(1,2,3) // [1,2,3]`                                      |

## 27. Разница между .call(), .apply() и bind()?

| Метод      | Что делает                                                                                                            | Пример                                   |
| ---------- |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------|
| `.call()`  | Вызывает функцию с указанным `this` и аргументами **по отдельности**                                                  | `fn.call(obj, arg1, arg2)`               |
| `.apply()` | Вызывает функцию с указанным `this` и аргументами **в виде массива**                                                  | `fn.apply(obj, [arg1, arg2])`            |
| `.bind()`  | Возвращает **новую функцию** с указанным `this` и, опционально, с **частично переданными аргументами по отдельности** | `const newFn = fn.bind(obj, arg1, arg2)` |

## 28. Что такое IIFE?

`IIFE или Immediately Invoked Function Expression` — это функция, которая вызывается или выполняется сразу же после создания или объявления:

```javascript
(function() { /* code */ })();
```

## 29. Что такое псевдомассив arguments?

`arguments `— это коллекция аргументов, передаваемых функции. 
Он имеет свойство length и поддерживает обращение по индексу к элементам, но не является массивом, из-за чего не имеет методов forEach, reduce, filter, map и так далее.

В стрелочных функциях объект arguments не работает.

## 30. Разница между host-объектами и нативными объектами?

| Тип объекта      | Определение                                                           | Примеры                                                                            |
| ---------------- | --------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **Нативные**     | Встроенные объекты JavaScript, реализованные самим движком            | `Object`, `Array`, `Function`, `Date`                                              |
| **Host-объекты** | Предоставляются средой выполнения (не самим JS), зависят от окружения | В браузере: `window`, `document`, `XMLHttpRequest`; в Node.js: `process`, `Buffer` |

## 31. Почему результат сравнения 2х объектов это false? Как сравнить два объекта?

Объекты сравниваются по ссылке, а не по значению.

Даже если два объекта содержат одинаковые данные, они разные по ссылке, и сравнение obj1 === obj2 вернёт false.

```javascript
const a = { name: 'Alice' };
const b = { name: 'Alice' };

console.log(a === b); // false
```

Как сравнить два объекта

1. Поверхностное сравнение (Shallow Compare)

    Сравнивает только верхний уровень свойств.
    
    ```javascript
    function shallowEqual(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
    
      if (keys1.length !== keys2.length) return false;
    
      for (let key of keys1) {
        if (obj1[key] !== obj2[key]) return false;
      }
    
      return true;
    }
    ```

2. Глубокое сравнение (Deep Compare)

    Сравнивает все вложенные объекты рекурсивно.
    
    ```javascript
    function deepEqual(obj1, obj2) {
      if (obj1 === obj2) return true;
    
      if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || !obj1 || !obj2) {
        return false;
      }
    
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
    
      if (keys1.length !== keys2.length) return false;
    
      for (let key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) return false;
      }
    
      return true;
    }
    ```

3. С помощью `JSON.stringify`

    ```javascript
    const areEqual = JSON.stringify(obj1) === JSON.stringify(obj2);
    ```
    
    - Плюсы: Просто и быстро

    - Минусы: Порядок свойств имеет значение, не работает с функциями, undefined, Date и др.

4. С помощью библиотек

   - Lodash

    ```javascript
    const _ = require('lodash');
    _.isEqual(obj1, obj2);
    ```
    
    - fast-deep-equal
    
    ```javascript
    const deepEqual = require('fast-deep-equal');
    deepEqual(obj1, obj2);
    ```
    
    - Плюсы: мощные и гибкие, глубокое сравнение любых объектов

    - Минусы: требуется установка библиотеки

## 32. Что такое NaN? Как определить, что значение равно NaN?

`NaN (Not-a-Number)` - специальное значение, которое указывает, что результат операции не является числом.

Определить `NaN` можно с помощью функции `isNaN()` (Преобразует переданное значение в число, если это возможно, и затем проверяет, является ли оно NaN) или метода `Number.isNaN()` (Проверяет только те значения, которые уже являются NaN, и не выполняет никакого преобразования).

## 33. Что такое объектная обертка (Wrapper Objects)?

Объектные обертки (`String`, `Number`, `Boolean`, `Symbol` и `BigInt`) позволяют работать с примитивными значениями как с объектами,
предоставляя методы и свойства.

## 34. Как работает Boxing/Unboxing?

`Boxing` - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам
примитивного значения.

`Unboxing` - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

## 35. Как создать объект?

- Литерал объекта: `{ key: value }`
- `new Object()`
- `Object.create(proto)`

## 36. Дескрипторы?

Каждое свойство объекта имеет:

| Атрибут        | Значение     | Описание                                            |
| -------------- | ------------ | --------------------------------------------------- |
| `value`        | любое        | Значение свойства                                   |
| `writable`     | `true/false` | Можно ли изменить значение                          |
| `enumerable`   | `true/false` | Участвует ли в переборе (for...in, Object.keys)     |
| `configurable` | `true/false` | Можно ли удалить свойство или изменить его атрибуты |

Если configurable: false, то флаги изменить нельзя, свойство удалить нельзя, но значение можно изменить (если writable: true).

Получение дескриптора:

```javascript
let user = { name: "John" };
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log(descriptor);
/* 
{
  value: "John",
  writable: true,
  enumerable: true,
  configurable: true
}
*/
```

Изменение или создание свойства с дескриптором:

```javascript
Object.defineProperty(obj, propertyName, descriptor);
```

- obj — объект

- propertyName — имя свойства

- descriptor — объект с атрибутами

```javascript
Object.defineProperty(user, 'name', { writable: false });
user.name = 'Alice'; // не изменится
```

Определение нескольких свойств сразу:

```javascript
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false }
});
```

Получение всех дескрипторов:

```javascript
Object.getOwnPropertyDescriptors(user);
```

## 37. Для чего используется ключевое слово new?

`new` используется для создания нового объекта (экземпляра функции-конструктора или класса).

Что делает `new`:

1. Создаёт новый пустой объект.

2. Привязывает к нему this, чтобы ссылки внутри функции-конструктора указывали на этот объект.

3. Создаёт прототипную связь: объект наследует свойства и методы конструктора через [[Prototype]] (или __proto__).

4. Возвращает объект this, если функция не возвращает другой объект явно.

```javascript
function Person(name) {
  this.name = name;
}

const user = new Person('Alice');
console.log(user.name); // "Alice"
console.log(user instanceof Person); // true
```

## 38. Что такое Set, Map, WeakMap и WeakSet?

`Map` — коллекция пар "ключ-значение", где ключи могут быть любого типа. Порядок элементов в Map сохраняется.

Методы и свойства:

- `new Map()` – создаёт коллекцию.
- `Map.prototype.set(key, value)` – записывает по ключу key значение value.
- `Map.prototype.get(key)` – возвращает значение по ключу или undefined, если ключ key отсутствует.
- `Map.prototype.has(key)` – возвращает true, если ключ key присутствует в коллекции, иначе false.
- `Map.prototype.delete(key)` – удаляет элемент (пару «ключ/значение») по ключу key.
- `Map.prototype.clear()` – очищает коллекцию от всех элементов.
- `Map.prototype.size` – возвращает текущее количество элементов.

Для перебора коллекции Map:

- `Map.prototype.keys()` – возвращает итерируемый объект по ключам,
- `Map.prototype.values()` – возвращает итерируемый объект по значениям,
- `Map.prototype.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется
  по умолчанию в for..of.

`Set` — коллекция уникальных значений. Значения в Set могут быть любого типа и не повторяются.

Его основные методы это:

- `new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это
  массив), то копирует его значения в новый Set.
- `Set.prototype.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект
  Set.
- `Set.prototype.delete(value)` – удаляет значение, возвращает true, если value было в множестве на момент вызова,
  иначе false.
- `Set.prototype.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.
- `Set.prototype.clear()` – удаляет все имеющиеся значения.
- `Set.prototype.size` – возвращает количество элементов в множестве.

Для перебора коллекции Set:

- `Set.prototype.keys()` – возвращает перебираемый объект для значений,
- `Set.prototype.values()` – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
- `Set.prototype.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для
  обратной совместимости с Map.

`WeakMap` — аналог Map, но ключи должны быть объектами, и они не предотвращают сборку мусора. Это позволяет автоматически очищать неиспользуемые ключи.

`WeakSet` — аналог Set, но элементы могут быть только объектами, и они не предотвращают сборку мусора.

`WeakSet и WeakMap` – это специальные структуры данных, которые отличаются особенностью хранения ссылок на объекты.

В обычных `Set и Map` хранятся сильные ссылки на объекты. Это значит, что пока существует ссылка на объект в этих структурах, сборщик мусора не удалит этот объект из памяти, даже если больше нигде в коде нет ссылок на него.

И напротив, в WeakSet и WeakMap хранятся слабые ссылки. Это означает, что если объект, на который есть ссылка в этих структурах, больше недоступен в коде (т.е. нигде больше нет сильных ссылок на него), то сборщик мусора может удалить этот объект из памяти, даже если в WeakSet или WeakMap все еще есть ссылка на него. Таким образом, использование слабых ссылок позволяет не держать в памяти ненужные больше объекты и экономить память.

Кроме того, в WeakMap в качестве ключей могут использоваться только объекты, а не примитивные значения. А в WeakSet хранятся только объекты, без ключей.

## 39. Операторы «И», «ИЛИ» и «Нулевого слияния» (&&, || и ??)?

`&& (И)` возвращает первое ложное значение или последнее истинное.

`|| (ИЛИ)` возвращает первое истинное значение или последнее ложное.

`?? (оператор нулевого слияния)` возвращает первое значение, не равное null или undefined; если таких нет — возвращается последнее значение.

## 40. Что такое оператор логического присваивания?

`Оператор логического присваивания` сочетает логическое действие с присваиванием. Например, `x &&= y`
эквивалентен `x && (x = y)`.

## 41. Расскажите об операторе Optional Chaining (?.)?

`Оператор Optional Chaining (?.)` позволяет безопасно обращаться к вложенным свойствам объекта, не вызывая ошибку,
если одно из промежуточных свойств `null` или `undefined`. Например, `obj?.property?.subProperty`.

## 42. Как определить наличие свойства в объекте? Разница между оператором in и методом .hasOwnProperty()?

`in` проверяет наличие свойства в объекте и его прототипах.

`.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

## 43. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?

`Поверхностная копия (shallow)` копирует только верхний уровень объекта. Вложенные объекты остаются ссылками на исходный объект. Например, с помощью `Object.assign()` или оператора
распространения `{ ...obj }`.

```javascript
const obj = { a: 1, b: { c: 2 } };
const shallowCopy = { ...obj };

shallowCopy.b.c = 42;
console.log(obj.b.c); // 42 — вложенный объект изменился в исходном объекте
```

`Глубокая копия (deep)` копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или
библиотек вроде `lodash` (`_.cloneDeep(obj)`).

```javascript
const obj = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(obj));

deepCopy.b.c = 42;
console.log(obj.b.c); // 2 — исходный объект не изменился
```

## 44. Как передаются параметры в функцию: по ссылке или по значению?

Примитивные типы передаются `по значению`, объекты передаются `по ссылке`.

## 45. Что такое прототип объекта?

`Прототип объекта` - это объект, от которого другой объект наследует свойства и методы.

## 46. Что такое прототипное наследование? Как создать объект без прототипа?

`Прототипное наследование` - механизм, при котором объекты могут наследовать
свойства и методы от другого объекта (прототипа).

Объект без прототипа можно создать с помощью `Object.create(null)`.

## 47. Типы всплывающих окон?

1. `alert()`: 

    - Выводит сообщение с кнопкой "ОК".

    ```javascript
    alert("Это сообщение!");
    ```

2. `confirm()`: 

    - Отображает сообщение с двумя кнопками: "ОК" и "Отмена". Возвращает `true`, если нажата "ОК", и `false`, если "Отмена".

    ```javascript
    let result = confirm("Вы уверены?");
   
    if (result) {
        console.log("Пользователь подтвердил.");
    } else {
        console.log("Пользователь отменил.");
    }
    ```

3. `prompt()`: 

    - Позволяет пользователю ввести текст. Возвращает введенное значение или `null`, если пользователь нажал "Отмена".

    ```javascript
    let name = prompt("Введите ваше имя:");
   
    if (name !== null) {
        console.log("Привет, " + name + "!");
    }
    ```

## 48. Типы ошибок?

🔹 Общий объект ошибок
- Конструктор: `Error`

```javascript
const commonError = new Error('Общая ошибка. Проверьте код');
console.log(commonError.message); // 'Общая ошибка. Проверьте код'
console.log(commonError.name);    // 'Error'
```

- `message` — описание ошибки

- `name` — тип ошибки

🔹 Встроенные типы ошибок

| Ошибка           | Описание                                               | Пример                                                   |
| ---------------- | ------------------------------------------------------ | -------------------------------------------------------- |
| `SyntaxError`    | Синтаксическая ошибка                                  | `console.log(; ) // SyntaxError`                         |
| `ReferenceError` | Обращение к несуществующей переменной                  | `console.log(name) // ReferenceError`                    |
| `TypeError`      | Нарушение типа, некорректная операция                  | `null.length // TypeError`<br>`undefined() // TypeError` |
| `RangeError`     | Значение выходит за допустимый диапазон                | `new Array(1e12) // RangeError`                          |
| `URIError`       | Некорректная работа с URI                              | `decodeURIComponent('%') // URIError`                    |
| `EvalError`      | Ошибка при использовании `eval()` (редко используется) | `eval('console.log(null.length)')`                       |


## 49. Разница между typeof и instanceof?

`typeof` возвращает строку, указывающую тип примитива или объекта.

```javascript
typeof 42;           // "number"
typeof "hello";      // "string"
typeof true;         // "boolean"
typeof {};           // "object"
typeof null;         // "object" (историческая особенность)
typeof function(){}; // "function"
```

`instanceof` проверяет, является ли объект экземпляром определенного конструктора.

```javascript
[] instanceof Array;        // true
// {} instanceof Object;  true
new Date() instanceof Date; // true
42 instanceof Number;       // false, примитивы не проходят
```

## 50. Что такое регулярное выражение (Regular Expression)? Какие методы используются в регулярных выражениях?

`Регулярное выражение (RegExp, или regex)` — это шаблон, описывающий, какие строки нужно найти или обработать.

Используется для: поиска, замены, проверки строк и валидации данных.

Основные элементы RegExp:

1. `Литералы` — простые символы, которые соответствуют самим себе (a, b, 1).

2. `Специальные символы`:

   - `.` — любой символ, кроме новой строки

   - `*` — 0 или более повторений предыдущего символа

   - `+` — 1 или более повторений предыдущего символа

   - `?` — 0 или 1 повторение предыдущего символа

   - `^` — начало строки

   - `$` — конец строки

   - `[]` — класс символов (например, [a-z] — любой символ от a до z)

   - `()` — группировка (например, (abc) соответствует строке "abc")

   - `|` — логическое «или» (например, a|b соответствует либо "a", либо "b")

3. `Экранирование` — для использования спецсимволов как литералов: \. соответствует точке ..

Методы для работы с регулярными выражениями:

| Метод              | Описание                                    | Пример                                       |
| ------------------ | ------------------------------------------- | -------------------------------------------- |
| `RegExp`           | Конструктор                                 | `const regex = new RegExp('abc');`           |
| `String.match()`   | Возвращает массив совпадений или `null`     | `'abcdef'.match(/abc/) // ['abc']`           |
| `String.replace()` | Заменяет совпадения                         | `'abcdef'.replace(/abc/, 'xyz') // 'xyzdef'` |
| `String.search()`  | Возвращает индекс первого совпадения или -1 | `'abcdef'.search(/abc/) // 0`                |
| `String.split()`   | Делит строку по шаблону                     | `'a,b,c'.split(/,/) // ['a','b','c']`        |
| `RegExp.test()`    | Проверяет наличие совпадения (true/false)   | `/abc/.test('abcdef') // true`               |

## 51. Что такое полифил (polyfill)?

`Полифил` — это код, который добавляет поддержку новых функций и методов в старые браузеры, где они не реализованы.

Цель: позволить разработчикам использовать современные возможности JavaScript, не дожидаясь, пока все пользователи обновят браузеры.

Пример: метод Array.prototype.includes

```javascript
if (!Array.prototype.includes) {
    Array.prototype.includes = function(element) {
        return this.indexOf(element) !== -1;
    };
}
```

- Проверяем, есть ли метод.

- Если нет — добавляем реализацию.

## 52. Типы операторов?

- Арифметические: `+`, `-`, `*`, `/`, `%`
- Сравнения: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
- Логические: `&&`, `||`, `!`
- Присваивания: `=`, `+=`, `-=`, `*=`, `/=`
- Побитовые: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
- Специальные: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

## 53. Правила задания имён для переменных и функций?

1. Начало имени

   - Имя должно начинаться с буквы, знака доллара $ или подчёркивания _.

   - Нельзя начинать с цифры.

2. Состав имени

   - Может содержать буквы, цифры, $ и _.

   - Чувствительно к регистру (myVar ≠ MyVar).

3. Читаемость

   - Имена должны быть понятными и описательными.

4. Запрещённые слова

   - Нельзя использовать зарезервированные слова (if, for, class, return и т.д.).

✅ Пример корректных имён:

```javascript
let name;
let $price;
let _count;
let totalAmount;
```

❌ Некорректные имена:

```javascript
// let 1name;  начинается с цифры
// let for;  зарезервированное слово
```

## 54. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?

`Явное преобразование`: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).

`Неявное преобразование`: JavaScript автоматически преобразует типы в процессе выполнения.

## 55. Что такое каррирование?

`Каррирование (Currying) `— это техника функционального программирования, которая преобразует функцию с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент.

```javascript
// Обычная функция
function add(x, y) {
    return x + y;
}

// Каррированная функция
function curriedAdd(x) {
    return function(y) {
        return x + y;
    };
}

const addFive = curriedAdd(5);
console.log(addFive(3)); // 8

// const curriedAdd = x => y => x + y; короткий современный вариант через стрелочные функции
```

## 56. Как работает «сборщик мусора»?

`Сборщик мусора (Garbage Collector, GC)` — это механизм, который автоматически освобождает память, удаляя объекты, на которые больше нет ссылок и которые не используются.

🔹 Основные принципы

1. Отслеживание ссылок (Reference Counting / Reachability)

   - Объект считается живым, если к нему есть доступ через глобальные переменные, стек вызовов или цепочку объектов.

   - Если объект недостижим (нет ссылок), сборщик мусора может его удалить.

2. Алгоритмы сборки мусора

   - Mark-and-Sweep (Пометка и удаление):

     1. Сборщик проходит по всем доступным объектам и помечает их как “живые”.
    
     2. Все непомеченные объекты считаются “мёртвыми” и удаляются из памяти.
    
    - Другие техники: копирование, генерационная сборка (часто в современных движках для оптимизации).

🔹 Особенности

- Сборщик мусора работает автоматически, программисту не нужно явно освобождать память.

- Важно избегать утечек памяти, чтобы GC мог корректно очищать объекты.

## 57. Что такое утечки памяти? Основные типы утечек памяти?

`Утечка памяти` — это ситуация, когда программа не освобождает память после использования объектов, что может привести к её исчерпанию и снижению производительности.

Основные типы утечек:

1. Задержки ссылок (Reference Retention)

   - Объекты остаются доступными из других объектов, хотя больше не нужны.

   - Часто связано с глобальными переменными или переменными в замыканиях.

2. Замыкания (Closures)

   - Функции сохраняют ссылки на переменные внешней области видимости.

     - Если функция живёт долго, объекты, на которые есть ссылки, не освобождаются.

3. Обработчики событий (Event Handlers)

   - Если обработчики не удаляются после использования, они удерживают ссылки на DOM-элементы или объекты.

4. Неочищенные таймеры и интервалы (Uncleared Timers / Intervals)

   - Таймеры (setTimeout, setInterval), которые не очищаются, удерживают функции и связанные объекты.

5. Кэширование (Caching)

   - Если объекты кэшируются и кэш не очищается, память постепенно расходуется на ненужные данные.

6. Неосвобождённые DOM-элементы

   - Созданные, но не удалённые элементы DOM остаются в памяти, даже если они не видимы на странице.

7. Ошибки в библиотеках и фреймворках

   - Некоторые библиотеки могут содержать свои утечки памяти из-за неправильного управления объектами.

## 58. Почему typeof null возвращает object?

`typeof null` возвращает `object` по историческим причинам.

Когда JavaScript создавался, значение null внутренне представлялось как "null pointer" и имело тип 0 в машинном представлении.

Функция typeof смотрела на внутренний тег типа, и поэтому null ошибочно определялся как объект.

Из-за обратной совместимости это поведение сохранилось, и менять его уже нельзя, иначе сломались бы миллионы сайтов.

Для проверки null всегда используйте строгое сравнение ===.

```javascript
function isNull(value) {
  return value === null;
}

console.log(isNull(null)); // true
console.log(isNull({}));   // false
```

## 59. Что такое модули, import/export?

`ES6 модули` позволяют организовывать код в модули, которые могут экспортировать (`export`) и импортировать (`import`) функциональность.

Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле.

## 60. Proxy и Reflect?

🔹`Proxy` — это обёртка вокруг объекта, которая позволяет перехватывать и изменять поведение операций с этим объектом.

```javascript
let proxy = new Proxy(target, {
  /* ловушки (traps) */
});
```

Основная идея:

Если операция не перехвачена, она автоматически перенаправляется на target.

Если есть «ловушка» (trap), то она выполняется вместо обычного поведения.

Часто используемые ловушки:

- `get` — чтение свойства

- `set` — запись свойства

- `deleteProperty` — удаление свойства

- `apply` — вызов функции

- `construct` — вызов через new

```javascript
let user = { name: "Вася" };

let proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`GET ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`SET ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.name;      // GET name
proxy.name = "Петя"; // SET name = Петя
```

🔹`Reflect` — это встроенный объект, который предоставляет методы для обращения к внутренним операциям,
таким как чтение, запись, удаление свойств и вызов функций.
Методы Reflect соответствуют ловушкам Proxy (один к одному).

```javascript
let user = {};

Reflect.set(user, 'name', 'Вася');
console.log(Reflect.get(user, 'name')); // Вася
let user = {};

Reflect.set(user, 'name', 'Вася');
console.log(Reflect.get(user, 'name')); // Вася
```

Типичный случай использования:

Внутри прокси ловушка вызывает Reflect, чтобы “прозрачно” передать действие оригинальному объекту:

```javascript
let user = { name: "Вася" };

let proxy = new Proxy(user, {
  get(target, prop, receiver) {
    console.log(`GET ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log(`SET ${prop} = ${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
});
```

Ключевые моменты

- Proxy позволяет изменять поведение объектов.

- Reflect — удобный способ вызвать стандартное поведение внутри ловушек.

- Для каждой ловушки Proxy есть соответствующий метод в Reflect.

- Некоторые вещи нельзя проксировать (встроенные слоты, приватные поля, ===).

- Прокси немного медленнее обычных объектов.

[LearnJS](https://learn.javascript.ru/proxy#reflect)

## 61. Разница постфикса и префикса инкремента и декремента?

`Префиксный инкремент/декремент (++x или --x):` сначала изменяет значение переменной, затем возвращает изменённое значение.

`Постфиксный инкремент/декремент (x++ или x--):` сначала возвращает текущее значение переменной, затем изменяет её значение.

## 62. Разница между синхронными и асинхронными функциями?

`Синхронные функции` выполняются последовательно, одна за другой. Это означает, что следующая строка кода не будет
выполнена, пока текущая функция не завершится. 

`Асинхронные функции` позволяют выполнять код параллельно, не блокируя
выполнение последующих строк кода. Они могут завершаться позже, чем последующие операции.

## 63. Что такое AJAX?

`AJAX (Asynchronous JavaScript and XML)` — это подход к разработке веб-приложений, позволяющий обмениваться данными с сервером асинхронно,
без перезагрузки страницы. AJAX использует объект XMLHttpRequest (или современный метод fetch()) для отправки и получения данных с сервера.

## 64. Что такое fetch()?

`fetch()` — это встроенная функция, используемая для выполнения HTTP-запросов.
Возвращает промис, который разрешается в ответ на запрос.

## 65. Что такое JSON? Отличие от XML?

`JSON (JavaScript Object Notation)` - это формат для обмена данными между клиентом и сервером, основанный на JavaScript-объектах. Его можно парсить и сериализовать с помощью `JSON.parse()` и `JSON.stringify()`.

Различия JSON и XML:

- `JSON (JavaScript Object Notation):` легковесный формат для хранения и передачи данных, легко
  читается человеком и машиной.
- `XML (eXtensible Markup Language):` более сложный формат для хранения и передачи данных, использующий разметку
  для определения структуры.

## 66. Что такое цикл событий (Event Loop)? Как он работает? Разница между микро и макрозадачами?

`Цикл событий (Event Loop)` — это механизм, который позволяет JavaScript оставаться однопоточным, но при этом эффективно выполнять асинхронный код без блокировки основного потока.

Основные компоненты JavaScript-окружения:

1. Call Stack (Стек вызовов)

   - Хранит выполняемый код, работает по принципу LIFO (последним вошёл — первым вышел).

   - Когда функция вызывается — помещается в стек; после выполнения — удаляется.

2. Heap (Куча)

   - Область памяти для объектов и других ссылочных данных, которая хранит данные динамического размера: объекты и массивы, на которые стек содержит лишь ссылки.

3. Web APIs / Node APIs

   - Среда выполнения (браузер или Node.js) предоставляет асинхронные возможности, которые не выполняются в JS-движке напрямую: таймеры, сетевые запросы, события DOM.

   - Когда операция завершается, её колбэк попадает в очередь задач соответствующего типа.

4. Очереди задач, работают по принципу FIFO (первым вошел - первым вышел)

   - Микрозадачи (Micro Task Queue) — выполняются внутри JS-движка, без участия внешней среды сразу после опустошения стека.
     Примеры: Promise.then/catch/finally, queueMicrotask, process.nextTick.

   - Макрозадачи (Macro Task Queue) — колбэки асинхронных операций среды, которые будут выполнены позже, после микрозадач.
     Примеры: setTimeout, setInterval, fetch, обработчики событий, requestAnimationFrame.

Как работает Event Loop:

1. Выполняется весь синхронный код. Пока стек не пуст — Event Loop ждет.

2. Асинхронные операции, которые требуют внешней среды (таймеры, сетевые запросы, события), инициируются через Web API/Node API: асинхронные операции, которые не требуют внешней среды, выполняются внутри JS-движка.

3. Когда асинхронная операция завершается, её колбэк помещается в очередь микрозадач или макрозадач.

4. Когда стек пуст:

   - Event Loop выполняет все микрозадачи из очереди.

   - Затем берётся одна макрозадача, её колбэк помещается в стек и выполняется.

   - Если во время макрозадачи создаются новые микрозадачи, они выполняются сразу после завершения текущего стека.

5. Цикл повторяется бесконечно: сначала микрозадачи, потом макрозадача, и снова микрозадачи.

Разница между микрозадачами и макрозадачами:

| Характеристика        | Микрозадачи                                                                 | Макрозадачи                                                                       |
| --------------------- |-----------------------------------------------------------------------------| --------------------------------------------------------------------------------- |
| **Приоритет**         | Выполняются **раньше**, чем макрозадачи                                     | Выполняются **после** всех микрозадач                                             |
| **Очередь**           | Micro Task Queue                                                            | Macro Task Queue                                                                  |
| **Примеры**           | `Promise.then`, `catch`, `finally`, `queueMicrotask`, `process.nextTick`    | `setTimeout`, `setInterval`, `fetch`, обработчики событий, `requestAnimationFrame` |
| **Когда выполняются** | Сразу после завершения текущего стека вызовов, перед следующей макрозадачей | После того, как завершены все микрозадачи текущего цикла                          |

💡 Важно помнить:

- Event Loop не является частью JS-движка (например, V8) — он реализуется средой выполнения (браузер или Node.js).

- Микрозадачи всегда выполняются раньше макрозадач.

## 67. Расскажите о queueMicrotask?

`queueMicrotask()` добавляет переданную функцию в очередь микрозадач.

## 68. Что такое callback-функция? Что такое Callback Hell?

`Callback-функция` — это функция, передаваемая в качестве аргумента другой функции и 
вызываемая по мере выполнения этой функции. 

Это позволяет выполнять асинхронные операции и обрабатывать их результаты, когда они становятся доступны.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Данные загружены";
        callback(data);
    }, 1000);
}

fetchData((result) => console.log(result)); // Выводит "Данные загружены" через 1 секунду);
```

`Callback Hell (или “ад обратных вызовов”)` — это ситуация, когда код содержит много вложенных callback-функций,
что делает его трудночитаемым и сложным для поддержки.

```javascript
fetchData(result1 => {
    console.log(result1);
    fetchData(result2 => {
        console.log(result2);
        fetchData(result3 => {
            console.log(result3);
            // и так далее...
        });
    });
});
```

Проблему “callback hell” решают с помощью промисов и async/await, которые делают код асинхронных операций более читаемым.

## 69. Что такое промисы (Promises)?

`Promise` - это объект, представляющий результат асинхронной операции. Он может находиться в одном из трёх состояний:
`ожидание (pending)`, `выполнено (fulfilled)`, `отклонено (rejected)`. Промисы позволяют удобнее работать с асинхронным кодом,
избегая вложенных колбэков.

## 70. Методы промисов?

- `Promise.all()`

    Выполняется, когда все промисы успешно завершены.
    
    Если хотя бы один промис отклонён, возвращается ошибка этого промиса.

    ```js
    const promise1 = Promise.resolve(3);
    const promise2 = Promise.resolve(42);
    const promise3 = Promise.resolve('hello');
    
    Promise.all([promise1, promise2, promise3])
    .then(values => console.log(values)) // [3, 42, 'hello']
    .catch(error => console.error(error));
    ```

- `Promise.any()`

    Выполняется, когда хотя бы один из промисов успешно завершён.
    
    Если все промисы отклонены, возвращается ошибка типа AggregateError.
    
    ```js
    const promise1 = Promise.reject(new Error('Error 1'));
    const promise2 = Promise.resolve(42);
    const promise3 = Promise.reject(new Error('Error 2'));
    
    Promise.any([promise1, promise2, promise3])
        .then(value => console.log(value)) // 42
        .catch(error => console.error(error));
    ```

- `Promise.race()`

    Возвращает результат первого завершившегося промиса,
    независимо от того, успешно он выполнен или отклонён.

    ```js
    const promise1 = new Promise(resolve => setTimeout(resolve, 100, 'First'));
    const promise2 = new Promise(resolve => setTimeout(resolve, 200, 'Second'));
    
    Promise.race([promise1, promise2])
        .then(value => console.log(value)) // 'First'
        .catch(error => console.error(error));
    ```

- `Promise.allSettled()`

    Выполняется, когда все промисы завершены, независимо от результата.
    
    Возвращает массив объектов с состоянием каждого промиса (fulfilled или rejected).
    
    ```js
    const promise1 = Promise.resolve(3);
    const promise2 = Promise.reject(new Error('Error occurred'));
    const promise3 = Promise.resolve('hello');
    
    Promise.allSettled([promise1, promise2, promise3])
        .then(results => console.log(results));
    // [
    //   { status: 'fulfilled', value: 3 },
    //   { status: 'rejected', reason: Error('Error occurred') },
    //   { status: 'fulfilled', value: 'hello' }
    // ]
    ```

- `Promise.resolve()`

    Создаёт промис, который сразу успешно завершён с указанным значением.
    
    ```js
    const happyDog = Promise.resolve('🐶');
    
    happyDog.then(dog => console.log(dog)); // 🐶
    ```

- `Promise.reject()`

Создаёт промис, который сразу отклонён с указанной причиной.

```js
const sadDog = Promise.reject('🐶');

sadDog.catch(dog => console.log(dog)); // 🐶
```

## 71. Что такое async/await?

`async/await` - это синтаксический сахар для работы с промисами, который позволяет писать асинхронный код так, как
если бы он был синхронным. `async` помечает функцию как асинхронную, `await` заставляет ждать выполнения промиса.

## 72. Web Workers

[Дока](https://doka.guide/js/web-workers/)

## 73. Что такое ООП?

`ООП (объектно-ориентированное программирование)` — это парадигма программирования, основанная на представлении программы в виде совокупности объектов, которые взаимодействуют между собой.
Основные принципы ООП:

- `Инкапсуляция` — сокрытие внутренней реализации объекта и предоставление доступа только через публичный интерфейс (методы и свойства).

- `Наследование` — возможность создавать новые классы на основе существующих, наследуя их свойства и методы.

- `Полиморфизм` — возможность вызывать одинаковые методы у разных объектов, при этом результат зависит от конкретного типа объекта.

- `Абстракция` — выделение только значимых характеристик объекта, игнорируя детали реализации.

ООП реализуется через прототипное наследование, а с введением синтаксиса class (ES6) стало проще писать код в «классическом» стиле, сохраняя при этом прототипную природу языка.

## 74. Какие паттерны знаешь? (порождающие, структурные, поведенческие)

`Порождающие паттерны` — отвечают за создание объектов:

- Singleton (Одиночка) — гарантирует, что существует только один экземпляр объекта.

- Factory Method (Фабричный метод) — создаёт объекты через общий интерфейс без указания конкретного класса.

- Abstract Factory (Абстрактная фабрика) — создает семейства связанных объектов.

- Builder (Строитель) — пошагово конструирует сложные объекты.

- Prototype (Прототип) — создаёт объекты на основе существующего шаблона (прототипа).

`Структурные паттерны` — описывают, как классы и объекты образуют более крупные структуры:

- Adapter (Адаптер) — преобразует интерфейс одного класса к другому.

- Decorator (Декоратор) — динамически добавляет объекту новое поведение.

- Facade (Фасад) — упрощает сложную систему, предоставляя единый интерфейс.

- Proxy (Заместитель) — контролирует доступ к объекту, добавляя промежуточный слой.

- Composite (Компоновщик) — объединяет объекты в древовидную структуру.

`Поведенческие паттерны` — определяют взаимодействие между объектами:

- Observer (Наблюдатель) — один объект следит за изменениями другого.

- Strategy (Стратегия) — позволяет менять алгоритм поведения во время выполнения.

- Command (Команда) — инкапсулирует запрос как объект.

- Mediator (Посредник) — управляет взаимодействием между множеством объектов.

- State (Состояние) — изменяет поведение объекта при смене внутреннего состояния.

## 75. Как работают классы под капотом? Прототипы.

`Классы` — это синтаксический сахар над прототипами.
Под капотом при объявлении класса создаётся функция-конструктор, а все методы класса записываются в его свойство prototype.

```javascript
class User {
  sayHi() {
    console.log('Hi');
  }
}

const user = new User();
user.sayHi();
```

Под капотом эквивалентно:

```javascript
function User() {}
User.prototype.sayHi = function() {
  console.log('Hi');
};

const user = new User();
user.sayHi();
```

Каждый объект имеет скрытую ссылку [[Prototype]], доступную через __proto__, которая указывает на другой объект — его прототип.
Если у объекта нет нужного свойства, JavaScript ищет его в цепочке прототипов (prototype chain).

Таким образом:

- class = синтаксический сахар над функцией-конструктором;

- методы определяются в prototype;

- наследование реализуется через Object.create() или ключевое слово extends, которое устанавливает прототип родителя.

# Браузерный JavaScript

## 1. Что такое DOM и BOM?

`DOM (Document Object Model)` — это специальная древовидная структура, где каждый элемент HTML является объектом, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью
события DOMContentLoaded.

`BOM` — это набор объектов, предоставляемых браузером, который позволяет взаимодействовать с самой страницей, а не только с её содержимым. BOM не стандартизирован так, как DOM, и его функциональность может различаться в разных браузерах.

BOM позволяет управлять такими аспектами, как окна браузера (например, открытие и закрытие окон), история навигации, адресная строка и т.д.

**window** — основной объект, представляющий текущее окно браузера, позволяет управлять окнами и диалоговыми окнами. Например, можно использовать `window.alert('Привет, мир!')`.

**document** — представляет HTML-документ и предоставляет доступ к его элементам. Например, с помощью `document.title` можно получить заголовок документа.

**navigator** — предоставляет информацию о браузере и операционной системе, например, `navigator.userAgent` дает данные о браузере пользователя.

**location** — позволяет управлять текущим URL, например, `window.location.href = 'https://example.com'` перенаправляет на новый URL.

**history** — взаимодействует с историей браузера, позволяя переходить назад и вперед, например, `window.history.back()` вернет на предыдущую страницу.

**screen** — предоставляет информацию о размере экрана, например, `screen.width` возвращает ширину экрана.

## 2. Типы узлов DOM-дерева?

Основные типы узлов DOM-дерева:
- `Element`: узлы элементов, такие как `<div>`, `<p>`, `<a>`.
- `Attribute`: узлы атрибутов, связанные с элементами.
- `Text`: текстовые узлы, содержащие текст внутри элементов.
- `Comment`: узлы комментариев.
- `Document`: корневой узел документа.
- `DocumentFragment`: фрагмент документа, который можно использовать для временного хранения элементов.

## 3. Что такое распространение события (Event Propagation)?

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает всех предков целевого элемента.

Этот процесс называется Event Propagation (распространение события).

Event Propagation имеет три стадии

1. **`Фаза погружения`** — событие возникает в объекте window и опускается до цели события через всех ее предков.
2. **`Целевая фаза`** — это когда событие достигает целевого элемента.
3. **`Фаза всплытия`** — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
   объекта window.

## 4. Разница между e.preventDefault() и e.stopPropagation(), .stopImmediatePropagation()?

- `composedPath()` — вернёт массив элементов, на которых сработает событие.

- `preventDefault()` — предотвращает дефолтное поведение события. Если вызвать этот метод на событии клика по ссылке, то переход по ссылке не произойдёт, но событие продолжит всплытие.

- `stopPropagation()` — предотвращает всплытие события.

- `stopImmediatePropagation()` — делает то же самое, что и stopPropagation, но, в том числе, предотвращает вызов обработчиков события, которые были установлены на этом же элементе.

☝️
*Обработчики событий, установленные на элемент, вызываются по порядку их установки.*

## 5. Как узнать об использовании метода event.preventDefault()?
Чтобы определить, вызван ли метод `preventDefault`, можно проверить свойство `defaultPrevented` объекта события:

```javascript
handleEvent(e)
{
    if (e.defaultPrevented) {
        console.log('preventDefault был вызван');
    }
}
```

## 6. Что такое делегирование событий (Event Delegation)?

`Делегирование событий` — подход при работе с событиями DOM-дерева, при котором обработчики событий добавляются не на
каждый конкретный элемент, а только на общий родительский, в то время как необходимость вызова это обработчика для
конкретного интересующего нас элемента определяется через инициатора события, узнать который можно из свойства объекта
события event.target.

Такой подход возможен благодаря особенностям событийной модели DOM-дерева, а конкретно такой особенности, как всплытие
событий.

## 7. Разница между event.target и event.currentTarget?

- `event.target`: элемент, на котором произошло событие.
- `event.currentTarget`: элемент, на который назначен обработчик события (может отличаться, если используется
  делегирование событий).

## 8. Расскажите о IntersectionObserver?

`Intersection Observer` — браузерный API, который позволяет асинхронно отслеживать пересечение элемента с его родителем или областью видимости документа (viewport). В момент пересечения можно запустить какое-либо действие, например, подгрузить дополнительные посты в ленте новостей («бесконечный скролл») или сделать «ленивую» загрузку контента.

[Дока](https://doka.guide/js/intersection-observer/)

## 9. Методы поиска элементов в DOM?

- `document.getElementById(id)`: находит элемент по идентификатору.
- `document.getElementsByClassName(className)`: находит элементы по имени класса.
- `document.getElementsByTagName(tagName)`: находит элементы по имени тега.
- `document.querySelector(selector)`: находит первый элемент, соответствующий CSS-селектору.
- `document.querySelectorAll(selector)`: находит все элементы, соответствующие CSS-селектору.

## 10. Как добавить обработчик события на DOM-элемент?

   ```javascript
   element.addEventListener('event', function() {
     // обработчик события
   });
   ```
   Например:
   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
     alert('Button clicked!');
   });
   ```

## 11. Как удалить обработчик события с DOM-элемента?

   ```javascript
   element.removeEventListener('event', handler);
   ```
   Пример:
   ```javascript
   function handleClick() {
     alert('Button clicked!');
   }

   const button = document.getElementById('myButton');
   button.addEventListener('click', handleClick);
   // Удаление обработчика
   button.removeEventListener('click', handleClick);
   ```

## 12. Свойства для перемещения по DOM-дереву?

1. **`parentNode`** – возвращает родительский узел элемента.
   ```javascript
   const child = document.querySelector('.child');
   const parent = child.parentNode;
   console.log(parent); // Выведет родительский элемент .child
   ```

2. **`children`** – возвращает HTMLCollection дочерних элементов (только элементы, игнорируются текстовые узлы и комментарии).
   ```javascript
   const parent = document.querySelector('.parent');
   const children = parent.children;
   console.log(children); // Выведет коллекцию дочерних элементов
   ```

3. **`firstElementChild`** – возвращает первый дочерний элемент.
   ```javascript
   const parent = document.querySelector('.parent');
   const firstChild = parent.firstElementChild;
   console.log(firstChild); // Выведет первый дочерний элемент
   ```

4. **`lastElementChild`** – возвращает последний дочерний элемент.
   ```javascript
   const parent = document.querySelector('.parent');
   const lastChild = parent.lastElementChild;
   console.log(lastChild); // Выведет последний дочерний элемент
   ```

5. **`previousElementSibling`** – возвращает предыдущий элемент на одном уровне вложенности.
   ```javascript
   const current = document.querySelector('.current');
   const previous = current.previousElementSibling;
   console.log(previous); // Выведет предыдущий элемент на том же уровне
   ```

6. **`nextElementSibling`** – возвращает следующий элемент на одном уровне вложенности.
   ```javascript
   const current = document.querySelector('.current');
   const next = current.nextElementSibling;
   console.log(next); // Выведет следующий элемент на том же уровне
   ```

7. **`childNodes`** – возвращает NodeList, содержащий все дочерние узлы (включая текстовые узлы и комментарии).
   ```javascript
   const parent = document.querySelector('.parent');
   const nodes = parent.childNodes;
   console.log(nodes); // Выведет список всех дочерних узлов
   ```

8. **`firstChild`** – возвращает первый дочерний узел (включая текстовые узлы).
   ```javascript
   const parent = document.querySelector('.parent');
   const firstNode = parent.firstChild;
   console.log(firstNode); // Выведет первый дочерний узел (возможно, текстовый)
   ```

9. **`lastChild`** – возвращает последний дочерний узел.
   ```javascript
   const parent = document.querySelector('.parent');
   const lastNode = parent.lastChild;
   console.log(lastNode); // Выведет последний дочерний узел
   ```

## 13. Разница между attribute и property у DOM-элементов?

- `Attribute`: относится к HTML-атрибутам, как они указаны в исходном коде. Например, `<input type="text" />`
  имеет атрибут `type`.
- `Property`: относится к свойствам объекта в DOM. Например, `element.type` указывает на текущее значение
  свойства `type`, которое может отличаться от значения атрибута.

## 14. Виды событий?

1. `События взаимодействия с пользователем (UI Events):`
   - `click` — нажатие на элемент.
   - `dblclick` — двойное нажатие на элемент.
   - `mousedown` — нажатие кнопки мыши.
   - `mouseup` — отпускание кнопки мыши.
   - `mousemove` — перемещение мыши.
   - `mouseenter` — перемещение указателя в область элемента.
   - `mouseleave` — уход указателя с элемента.
   - `mouseover` — наведение указателя на элемент.
   - `mouseout` — указатель покидает элемент.
   - `contextmenu` — вызов контекстного меню (обычно по правому клику мыши).
   - `input` — изменение значения в элементе ввода.

2. `События клавиатуры (Keyboard Events):`
   - `keydown` — нажатие клавиши.
   - `keyup` — отпускание клавиши.
   - `keypress` — нажатие клавиши (устарело, лучше использовать `keydown` и `keyup`).

3. `События фокуса (Focus Events):`
   - `focus` — получение фокуса элементом.
   - `blur` — потеря фокуса элементом.

4. `События формы (Form Events):`
   - `submit` — отправка формы.
   - `reset` — сброс формы.
   - `change` — изменение значения элемента формы.
   - `input` — ввод данных в элемент формы.

5. `События загрузки (Load Events):`
   - `load` — полная загрузка ресурса (страница, изображение).
   - `unload` — выгрузка ресурса.
   - `beforeunload` — событие перед выгрузкой ресурса.
   - `error` — ошибка при загрузке ресурса.

6. `События мультимедиа (Media Events):`
   - `play` — начало воспроизведения.
   - `pause` — пауза воспроизведения.
   - `ended` — завершение воспроизведения.
   - `volumechange` — изменение уровня громкости.

7. `События касания (Touch Events):`
   - `touchstart` — касание экрана.
   - `touchmove` — движение пальца по экрану.
   - `touchend` — завершение касания экрана.

8. `События окна (Window Events):`
   - `resize` — изменение размера окна.
   - `scroll` — прокрутка страницы.

9. `Прочие события:`
   - `DOMContentLoaded` — событие, когда HTML-документ был полностью загружен и обработан, не дожидаясь загрузки стилей, изображений и других ресурсов.
   - `hashchange` — изменение хэша в адресной строке.
   - `popstate` — изменение состояния истории (например, при навигации назад/вперед).
   - `storage` — изменение данных в `localStorage` или `sessionStorage`.

## 15. Разница между событиями load и DOMContentLoaded?

1. `DOMContentLoaded`
    Событие `DOMContentLoaded` срабатывает, когда браузер полностью загрузил и построил DOM-дерево, но до того, как загружены такие внешние ресурсы, как стили, изображения и другие элементы.

    - Событие полезно, когда вам нужно, чтобы HTML и JavaScript могли взаимодействовать сразу после загрузки DOM, без ожидания загрузки всех ресурсов.
    
    ```javascript
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM полностью загружен и обработан');
      const element = document.querySelector('.my-element');
      // Можно безопасно взаимодействовать с DOM-элементами
    });
    ```
    В этом примере скрипт будет запущен, как только DOM-дерево будет построено, даже если изображения или стили еще не загружены.

2. `load`
    Событие `load` срабатывает, когда вся страница, включая все стили, изображения и другие внешние ресурсы, полностью загружена. Это полезно, если вам нужно выполнять действия, когда все ресурсы готовы к работе.

    ```javascript
    window.addEventListener('load', () => {
      console.log('Все ресурсы страницы загружены');
      const image = document.querySelector('.my-image');
      // Здесь вы можете быть уверены, что все изображения и стили загружены
    });
    ```
    В этом случае обработчик события сработает только после того, как все ресурсы, включая изображения и CSS, будут загружены.

Основные отличия:

- `DOMContentLoaded` срабатывает, когда DOM-структура полностью загружена, **но не обязательно** ресурсы, такие как изображения и стили.
- `load` срабатывает только тогда, когда **все ресурсы** страницы полностью загружены.

```javascript
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM полностью загружен, но не все ресурсы');
});

window.addEventListener('load', () => {
  console.log('Все ресурсы, включая изображения, загружены');
});
```

## 16. Разница между HTMLCollection и NodeList?

`HTMLCollection` и `NodeList` — это два типа коллекций, которые возвращаются при работе с DOM, но у них есть отличия:

1. **HTMLCollection**:
   - Возвращается методами, связанными с элементами HTML, например, `document.getElementsByClassName()` или `document.getElementsByTagName()`.
   - Содержит только **элементы**, то есть HTML-теги.
   - Это **живая** коллекция, что означает, что она автоматически обновляется, если элементы на странице изменяются (например, если добавляются новые элементы, соответствующие критериям коллекции).
   - Не поддерживает методы, такие как `forEach()`, и требует использования цикла `for` для итерации.

2. **NodeList**:
   - Возвращается методами, такими как `document.querySelectorAll()` или `childNodes`.
   - Может содержать **любой тип узлов** (теги, текстовые узлы, комментарии и т.д.).
   - Бывает как **статической**, так и **живой**: например, `childNodes` — это живая коллекция, а `querySelectorAll()` возвращает статическую коллекцию, которая не обновляется при изменениях в DOM.
   - Поддерживает метод `forEach()` (начиная с современных версий браузеров), что делает его удобным для итерации.

## 17. Как динамически добавить элемент на HTML-страницу?

```javascript
const newElement = document.createElement('div');
newElement.textContent = 'Привет, мир!';
document.body.appendChild(newElement);
```

## 18. Разница между feature detection, feature inference и анализом строки user-agent?

Разница между `feature detection`, `feature inference` и `анализом строки user-agent` заключается в подходах, используемых для определения возможностей браузера или устройства:

1. **Feature Detection (Обнаружение функций)**:
   - Это метод, который позволяет определить, поддерживает ли браузер или устройство определенные функции или API. Вместо того чтобы полагаться на информацию о браузере, разработчик может использовать JavaScript для проверки наличия конкретной функции.
   - Пример: использование `if ('geolocation' in navigator)` для проверки, поддерживает ли браузер API геолокации.

2. **Feature Inference (Вывод функций)**:
   - Этот подход основан на предположениях о возможностях браузера, исходя из известных факторов, таких как версия браузера или тип устройства. Он может использоваться для предсказания, какие функции могут быть доступны, основываясь на общих характеристиках.
   - Пример: если пользователь использует современный браузер, можно предположить, что он поддерживает такие функции, как CSS Grid или Flexbox.

3. **Анализ строки user-agent**:
   - Это метод, при котором информация о браузере или устройстве извлекается из строки user-agent, отправляемой браузером при каждом HTTP-запросе. Эта строка содержит информацию о браузере, его версии, операционной системе и иногда даже о типе устройства.
   - Пример: строка user-agent может выглядеть так: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3`, и разработчик может извлекать из нее информацию о браузере и его версии.

## 19. Сколько аргументов принимает addEventListener?

1. **`type`** (строка): Тип события, которое вы хотите слушать (например, `'click'`, `'mouseover'`, `'keydown'` и т.д.).
2. **`listener`** (функция): Функция, которая будет вызвана, когда событие произойдет. Это обработчик события.
3. **`options`** (объект или логическое значение, необязательный): Опции для настройки поведения события, такие как:
   - `capture`: Если `true`, обработчик будет вызван на этапе захвата события.
   - `once`: Если `true`, обработчик будет вызван только один раз после его добавления.
   - `passive`: Если `true`, это указывает браузеру, что обработчик не будет вызывать `preventDefault()`, что может улучшить производительность прокрутки.

Пример использования:

```javascript
element.addEventListener('click', function(event) {
    console.log('Элемент был нажат!');
}, { once: true });
```

## 20. Разница между innerHTML и outerHTML?

`innerHTML` и `outerHTML` — это свойства объекта DOM, которые используются для работы с HTML-содержимым элементов. Вот основные различия между ними:

- **`innerHTML`**: возвращает или устанавливает HTML-содержимое внутри элемента. То есть, оно включает только содержимое между открывающим и закрывающим тегами элемента, исключая сами теги.

- **`outerHTML`**: возвращает или устанавливает HTML-содержимое элемента вместе с самим элементом. То есть, оно включает как содержимое, так и открывающий и закрывающий теги элемента.

Предположим, у нас есть следующий HTML-код:

```html
<div id="myDiv">
    <p>Привет, мир!</p>
</div>
```

Использование `innerHTML`

```javascript
const div = document.getElementById('myDiv');
console.log(div.innerHTML); // Вывод: <p>Привет, мир!</p>
div.innerHTML = '<p>Новое содержимое!</p>'; // Изменяет содержимое внутри div
```

После выполнения кода, содержимое `div` будет заменено на `<p>Новое содержимое!</p>`.

Использование `outerHTML`

```javascript
const div = document.getElementById('myDiv');
console.log(div.outerHTML); // Вывод: <div id="myDiv"><p>Привет, мир!</p></div>
div.outerHTML = '<div id="newDiv"><p>Новое содержимое!</p></div>'; // Заменяет весь div
```

После выполнения кода, весь элемент `div` будет заменен на `<div id="newDiv"><p>Новое содержимое!</p></div>`.

## 21. Для чего используется метод .focus()?

Метод `.focus()` используется для установки фокуса на элемент пользовательского интерфейса, например, на поле ввода, кнопку или любой другой интерактивный элемент. Когда элемент получает фокус, он становится активным для ввода данных или взаимодействия, что обычно сопровождается выделением элемента.

Применение метода `.focus()`:

1. **Упрощение ввода данных**: Вы можете автоматически установить фокус на поле ввода при загрузке страницы или после выполнения определенного действия, что улучшает пользовательский опыт.

   ```javascript
   document.getElementById('myInput').focus();
   ```

2. **Управление формами**: При работе с формами, вы можете устанавливать фокус на следующем элементе после завершения ввода данных.

3. **Обеспечение доступности**: Правильное использование метода `.focus()` может улучшить доступность приложения для пользователей, использующих клавиатуру.

4. **Использование в модальных окнах**: При открытии модального окна можно установить фокус на первое поле ввода, чтобы пользователь мог сразу начать ввод данных.

```html
<input type="text" id="username" placeholder="Введите ваше имя">
<button onclick="setFocus()">Установить фокус на поле ввода</button>

<script>
function setFocus() {
    document.getElementById('username').focus();
}
</script>
```
В этом примере при нажатии кнопки фокус будет установлен на поле ввода с id "username".

## 22. Для чего используется свойство .forms?

Свойство `.forms` объекта `document` возвращает коллекцию всех форм в документе.

## 23. Для чего используется метод .scrollIntoView()?

Метод `.scrollIntoView()` прокручивает элемент так, чтобы он оказался видимым в области просмотра. Это может быть
полезно для приведения элемента в фокус.

## 24. Разница между методами .submit() и .requestSubmit()?

- `.submit()`: отправляет форму, обходя валидацию HTML5 и обработчики события `submit`.
- `.requestSubmit()`: отправляет форму, включая валидацию HTML5 и вызов обработчиков события `submit`.

## 25. Расскажите о URLSearchParams?

`URLSearchParams` — это класс, предоставляющий удобное API для формирования строки поисковых параметров, которую потом можно использовать для формирования полного адреса. Все параметры в строке будут закодированы для безопасной вставки в адрес. Также этот класс можно встретить как часть класса URL.

Пример:
```javascript
let params = new URLSearchParams('?name=John&age=30');
console.log(params.get('name')); // John
console.log(params.has('age'));  // true
params.append('city', 'New York');
console.log(params.toString()); // name=John&age=30&city=New+York
```

[Подробнее читать на Дока](https://doka.guide/js/urlsearchparams/)

## 26. Как можно создавать пользовательское событие (custom events)?

Событие может быть создано с помощью кода. Поле isTrusted в таком событии будет содержать значение false, а, значит, мы будем знать, что событие было вызвано не системно и не пользователем.

Создадим своё событие и вызовем его на window:
```javascript
const myEvent = new CustomEvent('my-event', {
  detail: {
    spicy: 123,
  },
})

window.addEventListener('my-event', function(evt) {
  console.log('В поле spicy:', evt.detail.spicy)
})

window.dispatchEvent(myEvent)

```

## 27. Расскажите о методе requestAnimationFrame()?

[LearnJS](https://learn.javascript.ru/js-animation)

## 28. Для чего используется свойство .dataset?

Свойство `dataset` позволяет считывать или устанавливать любые дата-атрибуты на HTML-элементе.

`Дата-атрибут `— это пользовательский атрибут на элементе, название которого начинается с data-, например data-testid. Дата атрибуты используются, чтобы хранить значения на элементах в HTML.

[Подробнее читать на Дока](https://doka.guide/js/element-dataset/)