# React

## 1. Что такое React?

`React` — библиотека для создания пользовательских интерфейсов, разработана Facebook в 2011 году. 

Основная идея — разбиение UI на компоненты и управление их состоянием.

Ключевые особенности:

- Компоненты — интерфейс строится из переиспользуемых компонентов.

- Однонаправленный поток данных — данные идут сверху вниз через props.

- React Fiber — новый механизм рендеринга, поддерживающий асинхронные обновления.

- JSX — синтаксис для описания UI в виде HTML-подобного кода внутри JS.

- Hooks — использование состояния и эффектов в функциональных компонентах.

- Декларативный UI — разработчик описывает что должно быть отображено в зависимости от определенного
  состояния, а не пошаговые изменения.

- Экосистема — множество библиотек (React Router, Redux и др.) и большое сообщество.

## 2. Техники оптимизации перфоманса React?

1. Мемоизация компонентов

   - React.memo(Component) — предотвращает перерисовку компонента, если props не изменились.

   - Используется для функциональных компонентов.

2. Мемоизация функций и значений

   - useCallback — мемоизирует функции, чтобы не создавать новые при каждой перерисовке.

   - useMemo — мемоизирует вычисленные значения, чтобы не пересчитывать их лишний раз.

3. Оптимизация списка и рендеринга

   - key у элементов списка для правильного обновления.

   - Виртуализация списков (react-window, react-virtualized) для длинных списков.

4. Разделение кода (Code Splitting)

   - React.lazy + Suspense — подгружает компоненты по требованию, уменьшает размер начального бандла.

5. Избегание лишних перерисовок

   - Поднять state выше (lifting state up) только там, где нужно.

   - Делать локальные state для часто обновляемых компонентов.

6. Оптимизация контекста

   - Контекст вызывает перерисовку всех подписанных компонентов — мемоизация и разбивка на несколько контекстов помогает.

7. Профилирование

   - Использовать React.Profiler или DevTools, чтобы выявлять медленные компоненты.

## 3. Лучшие практики безопасности в React?

Избегать XSS, не хранить секреты на клиенте, валидировать данные на сервере, использовать CSRF-токены и современные заголовки безопасности.

## 4. React Fiber

[Объяснение - React (продвинутый)](https://www.youtube.com/watch?v=HDajDASxn-w)

`React Fiber` — это механизм рендеринга в React, представленный в версии 16.

**2 фазы:**

1. Rendering and Reconciliation
2. Commit

**Принцип работы React Fiber:**

**Фаза 1. Rendering and Reconciliation**

1. Впервые создаётся дерево React-элементов.

2. Для каждого элемента создаётся Fiber Node, которая содержит информацию об этом элементе и хранит на него ссылку.
    - Элемент может пересоздаваться, но Fiber остаётся тем же, изменяется лишь ссылка (в течение всего жизненного цикла
      компонента существует один и тот же Fiber, который отслеживает состояние элемента между перерендерингами).
        - При маунте создаётся новый Fiber.
        - При апдейте Fiber не изменяется, а просто получает новую ссылку на элемент.
        - При удалении элемента Fiber также уничтожается.

3. Что представляет собой Fiber Node:

   ![fiber](./../assets/react/fiber-node.png)

4. Дерево Fiber на самом деле является связанным списком (Linked List), а не обычным деревом.

   ![fiber](./../assets/react/fiber.png)

    - Родительская нода связана только с одной дочерней нодой (даже если их несколько).
    - Каждый дочерний Fiber знает о своём родителе.
    - Дочерние ноды также связаны между собой (нода, о которой знает родитель, знает о своей соседней дочерней ноде, и
      так далее).

5. Связанный список Fiber начинается с Host Root ноды.

   ![Host Root](./../assets/react/host-root-hode.png)

6. **Работа = эффекты** — это такие задачи, как запросы данных, подписки и изменения в DOM.

   Эффекты имеют разные приоритеты, и приоритизированные эффекты переходят на вторую фазу — фазу Commit.

**Приоритетность эффектов:**

- Высокий приоритет — визуальные изменения (useLayoutEffect), которые должны быть выполнены сразу.
- Обычный приоритет — обновления состояния и эффекты, влияющие на UI (useEffect).
- Низкий приоритет — фоновые задачи, такие как предварительная загрузка данных.
- Блокирующий приоритет — эффекты, связанные с вводом пользователя.

7. При обновлениях существует текущее дерево `Current Tree`. Нода, в которой произошли изменения, помечается как
   изменённая. Строится новое дерево `Work-in-Progress Tree`. React начинает поочерёдно клонировать элементы, которые не
   изменились.
    - React проходит от Host Root ноды и спускается вниз по дереву к самой глубокой дочерней ноде. Если у неё нет
      работы, React поднимается выше и проверяет, есть ли работа у её родительской ноды и соседних дочерних нод. Если
      работа есть, она выполняется.

   После этого React возвращается к Host Root ноде, собирает список работы, приоритизирует эффекты и применяет изменения
   к реальному DOM. После этого дерево `Work-in-Progress Tree` становится новым `Current Tree`.

8. React может приостанавливать и отменять процесс рендеринга и reconciliation, сохраняя текущее состояние в ноде
   `Next Unit of Work`. Это позволяет React продолжать работу с того места, где он остановился, когда станет больше
   свободных ресурсов.

9. **requestIdleCallback** — это метод браузера, который позволяет запускать функции в моменты простоя основного потока.
   React использует его для выполнения фоновых задач, не блокируя интерфейс пользователя.

**Эвристики:**

- Элементы разных типов создают разные деревья.
   Под элементами разных типов подразумеваются по факту элемены с разными именами:
      Примеры: Был span стал div
               Был Component1 стал Component2
- Использование ключей (`key`) помогает React отслеживать стабильные элементы между рендерами, что ускоряет процесс
  сравнения.

**Фаза 2. Commit**

Эта фаза не может быть прервана.

В этой фазе React применяет все приоритизированные эффекты, собранные на первой фазе. Эти эффекты уже нельзя отменить, и
они обязательно должны быть отображены.

- Все изменения в DOM происходят до остальных эффектов.

1. Вносятся изменения в DOM.
2. Запускаются остальные эффекты, такие как `componentDidMount`, `componentDidUpdate` и подписки.

## 5. Хуки

`Хуки` – это функции, которые позволяют работать с состоянием, жизненным циклом и другими возможностями React в функциональных компонентах.

1. `useState`

   Используется для управления состоянием в функциональном компоненте.
    
    ```javascript
    const [value, setValue] = useState(defaultValue);
    ```
    - value — текущее значение состояния
    - setValue — функция для его изменения

    Если новое состояние зависит от предыдущего, можно передать колбек:
    
    ```javascript
    setValue(prev => prev + 1);
    ```

    ```javascript
    import React, {useState} from 'react';
    
    function Counter() {
        const [count, setCount] = useState(0);
    
        return (
            <div>
                <p>Счетчик: {count}</p>
                <button onClick={() => setCount(count + 1)}>Увеличить</button>
            </div>
        );
    }
    ```

---

2. `useEffect`

   Позволяет выполнять побочные эффекты: запросы, таймеры, подписки и т.д. Принимает функцию и массив зависимостей:

    ```javascript
    useEffect(() => {
      // эффект
      return () => { /* очистка при размонтировании (аналог componentWillUnmount) */ }; 
    }, [deps]);
    ```

    - `без зависимостей` → вызывается на каждый рендер (монтирование и обновление)
    
    - `[]` → вызывается один раз при монтировании (аналог componentDidMount)
    
    - `[deps]` → вызывается при при монтировании + каждый раз при изменении deps (аналог componentDidUpdate для конкретных данных)

    ```javascript
    import React, {useEffect, useState} from 'react';
    
    function Timer() {
    const [time, setTime] = useState(0);
    
        useEffect(() => {
            const timer = setInterval(() => {
                setTime(prev => prev + 1);
            }, 1000);
    
            return () => clearInterval(timer);
        }, []);
    
        return <div>Время: {time} секунд</div>;
    }
    ```

---

3. `useLayoutEffect`

   Аналог useEffect, но выполняется синхронно до отрисовки DOM (аналог getSnapshotBeforeUpdate). Нужен, когда эффект влияет на DOM (например, измерения, позиционирование).

    ```javascript
    import React, {useLayoutEffect, useRef} from 'react';
    
    function LayoutExample() {
        const divRef = useRef();
    
        useLayoutEffect(() => {
            divRef.current.style.color = 'red';
        }, []);
    
        return <div ref={divRef}>Этот текст станет красным</div>;
    }
    ```

---

4. `useContext`

    Используется для передачи данных через дерево компонентов, минуя промежуточные компоненты.

    ```javascript
    import React, {createContext, useContext} from 'react';
    
    // Создание контекста
    const LanguageContext = React.createContext('en');
    
    // Компонент Provider
    const LanguageProvider = ({children}) => {
    const [language, setLanguage] = React.useState('en');
    
        return (
            <LanguageContext.Provider value={{language, setLanguage}}>
                {children}
            </LanguageContext.Provider>
        );
    };
    
    // Компонент Consumer
    const Greeting = () => {
    const {language} = React.useContext(LanguageContext);
    
        return <h1>{language === 'en' ? 'Hello!' : '¡Hola!'}</h1>;
    };
    
    // Использование
    const App = () => (
    <LanguageProvider>
        <Greeting/>
    </LanguageProvider>
    );
    ```

    Основные элементы:
    
    - `createContext` — создание контекста

   - `Provider` — предоставляет значение

   - `useContext` — позволяет получить это значение внутри компонента

   - `Consumer` — позволяет компонентам получать данные из контекста
    
    ```jsx
    // Создание контекста
    const LanguageContext = React.createContext('en');
    
    // Компонент Provider
    const LanguageProvider = ({children}) => {
        const [language, setLanguage] = React.useState('en');
    
        return (
            <LanguageContext.Provider value={{language, setLanguage}}>
                {children}
            </LanguageContext.Provider>
        );
    };
    
    // Компонент Consumer
    const Greeting = () => {
        const {language} = React.useContext(LanguageContext);
    
        return <h1>{language === 'en' ? 'Hello!' : '¡Hola!'}</h1>;
    };
    
    // Использование
    const App = () => (
        <LanguageProvider>
            <Greeting/>
        </LanguageProvider>
    );
    ```
    
    ⚠️ Важно: при изменении значения контекста перерисовываются все компоненты, использующие useContext.

---

5. `useReducer`

    Предназначен для управления состоянием, при сложной логике изменения состояния или когда текущее состояние зависит от предыдущего. 
    
    Он принимает редуктор (reducer), который обновляет состояние на основе действия (action): типа (type) и,
    опционально, полезной нагрузки (payload).
    
    ```javascript
    import React, {useReducer} from 'react';
    
    const initialState = {count: 0};
    
    function reducer(state, action) {
        switch (action.type) {
            case 'increment':
                return {count: state.count + 1};
            case 'decrement':
                return {count: state.count - 1};
            default:
                throw new Error();
        }
    }
    
    function Counter() {
        const [state, dispatch] = useReducer(reducer, initialState);
    
        return (
            <>
                Count: {state.count}
                <button onClick={() => dispatch({type: 'increment'})}>+</button>
                <button onClick={() => dispatch({type: 'decrement'})}>-</button>
            </>
        );
    }
    ```

---

6. `useCallback`

    Возвращает мемоизированную функцию, которая пересоздаётся только при изменении зависимостей.

    Полезен, когда передаётся функция как пропсы в дочерние компоненты и нужно избежать их пересоздания, что может привести к ненужным рендерам дочерних компонентов.
    
    ```javascript
    import React, {useCallback, useState} from 'react';

    function Button({onClick}) {
        console.log('Кнопка перерисована');
        return <button onClick={onClick}>Нажми меня</button>;
    }
    
    function App() {
        const [count, setCount] = useState(0);
    
        const handleClick = useCallback(() => {
            setCount(prev => prev + 1);
        }, []);
    
        return (
            <>
                <Button onClick={handleClick}/>
                <p>Счетчик: {count}</p>
            </>
        );
    }
    ```

---

7. `useMemo`

    Мемоизирует результат вычислений, чтобы не пересчитывать их при каждом рендере.

    Полезен, когда есть дорогостоящие вычисления, которые не нужно пересчитывать, если
    зависимости не изменились.
    
    ```javascript
    import React, {useMemo, useState} from 'react';
    
    function App() {
        const [count, setCount] = useState(0);
    
        const expensiveValue = useMemo(() => {
            return count * 2; // допустим, это тяжёлая операция
        }, [count]);
    
        return (
            <>
                <p>Счетчик: {count}</p>
                <p>Значение: {expensiveValue}</p>
                <button onClick={() => setCount(count + 1)}>+</button>
            </>
        );
    }
    ```

---

8. `useRef`

    Хранит мутируемое значение, которое не вызывает ререндер при изменении.
    Используется для доступа к DOM-элементам или сохранения любого значения между рендерами (как this.something в классовом).
    
    ```javascript
    import React, {useRef} from 'react';
    
    function FocusInput() {
        const inputRef = useRef();
    
        const focusInput = () => {
            inputRef.current.focus();
        };
    
        return (
            <>
                <input ref={inputRef} type="text"/>
                <button onClick={focusInput}>Фокус</button>
            </>
        );
    }
    ```

    Важно:

    - `ref.current` можно менять без ререндера

    - в `ref` можно хранить не только DOM-элемент, но и любое значение

    - для проброса `ref` в дочерний компонент используют `forwardRef`

    ```jsx
    import React, {forwardRef} from 'react';
    
    // Компонент Input, который принимает ref
    const Input = forwardRef((props, ref) => {
    return <input ref={ref} {...props} />;
    });
    
    export default Input;
    ```

    Ситуации, в которых использование рефов является оправданным:

    - Управление фокусом
    - Выделение текста
    - Вызов scrollTo
    - Вызов анимаций
    - Интеграция со сторонними DOM-библиотеками

---

9. Правила создания пользовательского хука:

   - Название хука должно начинаться с use.
   - Следует использовать сначала встроенные хуки, если они решают нужную задачу, прежде чем создавать свои.
   - Нельзя вызывать хук условно. Хук надо вызывать тогда, когда это необходимо.
   - В хуке должна быть только логика, которую можно использовать повторно. Не стоит добавлять в него код, который нужен
     только в одном месте.
   - Хук должен быть чистой функцией.
   - Хук может возвращать значение или вызывать другие хуки. Это позволяет создавать цепочки обработки данных.
   - Название хука должно быть понятным и отражать его назначение. Это поможет другим разработчикам понять, что делает этот
     хук и как его можно использовать.

## 6. React.memo?

`React.memo` - это компонент высшего порядка (HOC), который предотвращает повторный рендеринг компонента, если его пропсы не изменились, в функциональных компонентах.

```jsx
const MyComponent = React.memo((props) => {
// компонент рендерится только если props изменяются
    return <div>{props.value}</div>;
});
```

## 7. Что Такое JSX?

`JSX (JavaScript XML)` — это синтаксический сахар для описания структуры UI в JavaScript, который позволяет писать
HTML-подобный код внутри JavaScript-файлов.

## 8. Что такое фрагмент (Fragment)?

`Фрагмент (Fragment)` — это специальный элемент, позволяющий возвращать группу элементов без
помещения их в дополнительный DOM узел.

## 9. Разница между элементом, компонентом и контейнером?

- `Элемент`: Основной строительный блок React, описывающий, что отображается на экране. React-элементы иммутабельны.

- `Компонент`: Функция или класс, возвращающий элемент или элементы для отображения. Может быть как чисто визуальным,
так и содержать логику.

- `Контейнер`: Компонент, который управляет состоянием и передачей данных другим компонентам.

## 10. Для чего нужен атрибут key при рендере списков?

`Атрибут key` используется для идентификации элементов в списке. Это помогает React более эффективно обновлять и
перерисовывать только измененные элементы списка, минимизируя затраты на рендеринг.

## 11. Что такое Компонент высшего порядка (Higher-Order Component/HOC)?

`Компонент высшего порядка (Higher-Order Component, HOC)` — это паттерн, который позволяет повторно использовать
логику между разными компонентами. HOC представляет собой функцию, которая принимает компонент и возвращает новый
компонент с добавленной функциональностью.

```jsx
// Функция HOC
const withLogging = (WrappedComponent) => {
    return (props) => {
        console.log('Props:', props);
        return <WrappedComponent {...props} />;
    };
};

// Компонент, который мы оборачиваем
const MyComponent = ({message}) => {
    return <div>{message}</div>;
};

// Использование HOC для оборачивания компонента
const MyComponentWithLogging = withLogging(MyComponent);

// В рендере
<MyComponentWithLogging message="Hello, HOC!"/>
```

## 12. Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?

`Управляемые компоненты:`

Это компоненты, у которых отображение зависит от состояния, и состояние зависит от того, что отображается.
React полностью управляет значением элемента — оно хранится в state, а изменения происходят через setState.

```jsx
function ControlledInput() {
    const [inputValue, setInputValue] = useState('');

    const handleChange = (e) => {
        setInputValue(e.target.value);
    };

    return (
        <input
            type="text"
            value={inputValue}
            onChange={handleChange}
        />
    );
}
```

`Неуправляемые компоненты:`

У таких компонентов состояние хранится внутри самого DOM-элемента, и React не отслеживает его напрямую.
Чтобы получить значение, используется ref.

```jsx
function UncontrolledInput() {
    const inputRef = useRef();
    
    const handleSubmit = () => console.log(inputRef.current.value);
    
    return <>
        <input ref={inputRef} />
        <button onClick={handleSubmit}>Submit</button>
    </>;
}
```

## 13. Как в React реализовать двустороннее связывание данных?

`Двустороннее связывание данных (two-way data binding)` можно реализуется с помощью контролируемых компонентов.
Это процесс, когда изменения в интерфейсе пользователя (например, в форме) обновляют состояние компонента, и, наоборот,
изменения в состоянии компонента обновляют интерфейс.

## 14. Стадии жизненного цикла компонента в React?

Жизненный цикл классового компонента делится на три основные фазы: монтирование, обновление и размонтирование, плюс стадия обработки ошибок.

1. `Монтирование (Mounting)`

    Это фаза, когда компонент создаётся и вставляется в DOM.

    - `constructor(props)` — вызывается перед монтированием компонента, используется для инициализации состояния и привязки методов.
    - `static getDerivedStateFromProps(props, state)` — вызывается перед каждым рендером, в том числе и на стадии
     монтирования. Используется для синхронизации состояния с изменениями в props.
    - `render()` — единственный обязательный метод. Возвращает JSX, который описывает UI компонента.
    - `componentDidMount()` — вызывается сразу после монтирования компонента в DOM. Здесь обычно выполняются побочные
     эффекты (например, запросы к API).

2. `Обновление (Updating)`

    Происходит при изменении состояния компонента.

    - `static getDerivedStateFromProps(props, state)` — вызывается перед каждым рендером при обновлении.
    - `shouldComponentUpdate(nextProps, nextState)` — позволяет предотвратить перерисовку компонента. Возвращает
    `true` (по умолчанию) или `false`.
    - `render()` — перерисовывает компонент на основе новых данных.
    - `getSnapshotBeforeUpdate(prevProps, prevState)` — вызывается перед обновлением в DOM и может использоваться для
    получения данных до самого обновления (например, позиция прокрутки).
    - `componentDidUpdate(prevProps, prevState, snapshot)` — вызывается после обновления компонента в DOM. Здесь можно
    совершить действия на основе изменений.

3. `Размонтирование (Unmounting)`

    Когда компонент удаляется из DOM.

    - `componentWillUnmount()` — вызывается перед размонтированием компонента. Используется для очистки ресурсов (таймеров, подписок и т.д.).

Дополнительные методы (стадия обработки ошибок):

- `componentDidCatch(error, info)` — используется для обработки ошибок, возникших в процессе рендеринга дочерних компонентов.
- `static getDerivedStateFromError(error)` — вызывается при возникновении ошибки в компоненте. Позволяет обновить состояние на основе ошибки.

## 15. Методы жизненного цикла компонента в React?

`Методы жизненного цикла компонента` позволяют управлять поведением компонента на разных этапах его существования:

1. `constructor(props)`:
    - Вызывается перед монтированием компонента.
    - Используется для инициализации состояния и привязки методов.

2. `render`:
    - Рендеринг компонента.

3. `componentDidMount()`*:
    - Вызывается сразу после того, как компонент был смонтирован.
    - Отличное место для выполнения запросов к API и добавления подписок.

4. `componentDidUpdate(prevProps, prevState, snapshot)`:
    - Вызывается после обновления компонента.
    - Используется для выполнения действий на основе изменений в пропсах или состоянии.
    - В качестве параметров передаются старые значения объектов `props` и `state`. Третий параметр - значение, которое возвращает метод `getSnapshotBeforeUpdate`

5. `componentWillUnmount()`:
    - Вызывается перед размонтированием компонента.
    - Полезен для очистки подписок или таймеров.

6. `shouldComponentUpdate(nextProps, nextState)`:
    - Позволяет оптимизировать производительность, позволяя вам контролировать, нужно ли перерисовывать компонент.
    - Возвращает `true` или `false`.

7. `getDerivedStateFromProps(nextProps, prevState)`:
    - Вызывается перед рендерингом, как при монтировании, так и при обновлении.
    - Используется для обновления состояния на основе изменений в пропсах.

8. `getSnapshotBeforeUpdate(prevProps, prevState)`:
    - Вызывается прямо перед обновлением DOM.
    - Он позволяет компоненту получить информацию из DOM перед возможным обновлением.
    - Возвращает в качестве значения какой-то отдельный аспект, который передается в качестве третьего параметра в метод `componentDidUpdate()` и может учитываться в `componentDidUpdate` при обновлении. Если нечего возвращать, то возвращается значение `null`.

9. `componentDidCatch(error, info)`:
    - Вызывается, когда происходит ошибка в любом дочернем компоненте.
    - Позволяет обрабатывать ошибки и показывать запасной интерфейс.

Источник - https://metanit.com/web/react/2.6.php.

## 16. Что такое предохранители (Error Boundaries)?

`Error Boundaries (Предохранители)` — это классовые компоненты, которые отлавливают ошибки в дочерних компонентах и отображают запасной UI вместо падения всего приложения.

Ключевые моменты:

- Работают только в классовых компонентах (хуков для этого нет).

- Ловят ошибки в методе рендера, в методах жизненного цикла и в конструкторах дочерних компонентов.

- Не ловят ошибки в:

    - обработчиках событий,

    - асинхронном коде (setTimeout, промисы),

    - серверном рендеринге,

    - самом предохранителе.

Основные методы:

- static getDerivedStateFromError(error) — обновляет состояние для отображения запасного UI.

- componentDidCatch(error, info) — позволяет логировать ошибку.

⚠️ Важно: У этих методов нет аналога в функциональных компонентах, используются только классовые Error Boundaries.

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error caught by Error Boundary:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Что-то пошло не так.</h1>;
    }
    return this.props.children;
  }
}

// Использование
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

## 17. Что такое PureComponent?

`React.PureComponent` — это классовый компонент, который автоматически реализует метод `shouldComponentUpdate` с поверхностным сравнением `props` и `state`. Если значения не изменились, повторный рендер не выполняется.

Основные моменты:

- Поверхностное сравнение — сравниваются только верхние уровни объектов. Для вложенных структур (`{a: {b: 1}}`) изменения могут не определиться → возможны баги.

- Оптимизация — уменьшает количество ненужных ререндеров.

- Использование — вместо `Component` можно наследоваться от `PureComponent`.

```javascript
import React, { PureComponent } from "react";

class MyComponent extends PureComponent {
  render() {
    return <div>{this.props.value}</div>;
  }
}
```

⚠️ Важно:

- Для функциональных компонентов аналог — React.memo.

- Если props или state — сложные объекты, изменения внутри них могут не отразиться (нужна иммутабельность).

## 18. Что такое портал (Portal)?

`Портал (Portal)` — это способ рендеринга дочерних компонентов в DOM-узле, который находится вне иерархии
родительского компонента. Это полезно в случаях, когда нужно отобразить компонент, например, модальное окно или
всплывающее меню, над другими компонентами, не нарушая их структуру.

Основные особенности порталов:

1. `Отдельный DOM-узел`: Компонент, использующий портал, будет отрисован в указанном узле, но всё еще будет частью
   иерархии компонентов React. Это значит, что он может продолжать получать контекст и события от родительских
   компонентов.

2. `Создание портала`: Для создания портала в React используется метод `ReactDOM.createPortal()`, который принимает
   два аргумента:
    - `children`: дочерние компоненты, которые вы хотите отобразить.
    - `container`: DOM-узел, в который будут отрисованы дочерние компоненты.

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Modal = ({children}) => {
    return ReactDOM.createPortal(
        <div className="modal">
            {children}
        </div>,
        document.getElementById('modal-root')
    );
};

const App = () => {
    return (
        <div>
            <h1>Приложение</h1>
            <Modal>
                <h2>Это модальное окно!</h2>
            </Modal>
        </div>
    );
};

export default App;
```

`Когда использовать порталы:`

- Для создания модальных окон, всплывающих уведомлений, тултипов и других компонентов, которые должны визуально "
  выходить" за пределы родительских контейнеров.
- Когда нужно избежать проблем с CSS-стилями:

`Избежание overflow:` Если родительский контейнер имеет стиль overflow: hidden, overflow: auto или overflow: scroll,
дочерние компоненты, рендерящиеся внутри этого контейнера, могут быть обрезаны или не отображаться полностью. Порталы
позволяют избежать этой проблемы, помещая модальные окна или всплывающие элементы в другой контейнер, который не
ограничен стилями родительского элемента.

`Позиционирование:` При использовании абсолютного или фиксированного позиционирования (например, position: absolute,
position: fixed) дочерние компоненты могут неправильно позиционироваться относительно родителя. Порталы могут помочь,
позволяя элементам позиционироваться относительно корневого DOM-узла, а не родительского компонента.

`Проблемы со слоями:` Если у вас есть несколько компонентов, которые накладываются друг на друга, порталы могут
помочь избежать проблем с z-индексом, позволяя вам управлять порядком отображения компонентов, независимо от их места в
иерархии компонентов.

`Упрощение управления стилями:` При использовании порталов вы можете применить стили к модальным окнам и другим
всплывающим элементам без влияния на другие компоненты в родительской иерархии, что упрощает управление стилями и их
переиспользование.

## 19. Разница между состоянием (state) и пропсами (props)?

`props` — это данные, которые компонент получает извне (от родителя). Они неизменяемы внутри компонента и используются для настройки или передачи информации.

`state` — это внутренние данные компонента, которыми он сам управляет. Изменение state вызывает перерисовку компонента.

## 20. Что такое синтетические события в React?

`В React синтетические события` — это обертка над нативными событиями браузера. Они создаются React для обеспечения
кросс-браузерной совместимости и улучшения производительности. Вот несколько ключевых моментов о синтетических событиях:

1. `Кросс-браузерная совместимость`: Синтетические события предоставляют единый интерфейс для событий, который
   работает одинаково во всех поддерживаемых браузерах, избегая различий в реализации событий между браузерами.

2. `Упрощение работы с событиями`: Синтетические события обеспечивают такие же свойства и методы, как и нативные
   события, например, `event.target`, `event.currentTarget`, `event.preventDefault()`, и `event.stopPropagation()`.

3. `Пул событий`: React использует пул событий, чтобы уменьшить количество объектов событий, создаваемых при каждом
   событии. Это позволяет эффективно управлять памятью. После того как событие обработано, React возвращает его в пул,
   что означает, что доступ к свойствам события возможен только внутри обработчика.

4. `Проброс событий`: Синтетические события поддерживают концепцию проброса событий (event bubbling), то есть они
   проходят через цепочку элементов от целевого элемента до корня дерева.

```jsx
function handleClick(event) {
    // Событие здесь будет синтетическим
    console.log(event.type); // 'click'
    console.log(event.target); // Целевой элемент
}

function App() {
    return (
        <button onClick={handleClick}>Click me</button>
    );
}
```

## 21. Что такое условный рендеринг (Conditional Rendering)?

`Условный рендеринг` позволяет отображать компоненты или элементы в зависимости от условий. Это можно сделать с помощью
условных операторов (`if`, тернарный оператор) внутри метода рендера или функции.

## 22. Разница между React и ReactDOM?

**`React`**: Библиотека для создания компонентов и управления состоянием.

**`ReactDOM`**: Библиотека, которая отвечает за рендеринг React-компонентов в реальный DOM.

## 23. Что такое строгий режим в React? Его преимущества?

`Строгий режим (<React.StrictMode>)` помогает выявлять потенциальные проблемы в приложении, такие как устаревшие API и
небезопасные методы. Он активирует дополнительные проверки и предупреждения в режиме разработки.

## 24. Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?

`Бурение пропсов` — это процесс передачи данных от родительского компонента через несколько уровней дочерних
компонентов.
Это можно избежать, используя контекст или менеджер состояния.

## 25. Что такое «опрос» (Polling)? Как его реализовать?

`Опрос (Polling)` — это метод регулярного получения данных от сервера. Реализуется с помощью `setInterval` для
периодического вызова
API в компоненте и обновления состояния.

## 26. Что такое сhildren?

`children` — это специальный пропс, который используется для передачи вложенных элементов или компонентов в компонент.

## 27. Что такое инверсия управления?

`Инверсия управления (IoC)` — это принцип, при котором компонент не управляет поведением сам, а делегирует управление извне (например, через props, колбэки или render props).

## 28. Разница между классовым и функциональным компонентами?

`Классовые компоненты`:  Определяются как классы, поддерживают методы жизненного цикла и могут
использовать состояние.

`Функциональные компоненты`: Определяются как функции и могут использовать хуки для управления состоянием, жизненным циклом и другими возможностями React.

## 29. Что такое поднятие состояния вверх (Lifting State Up)?

`Поднятие состояния вверх (Lifting State Up)` — это паттерн, когда несколько компонентов должны использовать одно и то же состояние. Вместо хранения состояния в каждом компоненте отдельно, оно поднимается в ближайший общий родитель, который управляет состоянием и передаёт его дочерним компонентам через props.

## 30. Что такое обратный поток данных?

`Обратный поток данных` — это когда данные передаются от дочернего компонента к родительскому. Обычно данные идут сверху вниз через props, но иногда дочерний компонент должен сообщить родителю о событиях или изменениях.
Суть: родитель передаёт функцию, а дочерний компонент вызывает её, чтобы «поднять» данные вверх.

## 31. Разница между createElement() и cloneElement()?

- `createElement()`:
    - Используется для создания нового элемента React.
    - Формат вызова: `React.createElement(type, props, ...children)`.
    - `type` — это тип элемента (например, строка для HTML-элемента или класс/функция для пользовательского компонента).
    - `props` — объект с атрибутами и свойствами элемента.
    - `children` — дочерние элементы, которые будут вложены в создаваемый элемент.

   ```jsx
   const element = React.createElement('div', { className: 'my-class' }, 'Hello, world!');
   ```

   Этот код создаст элемент `<div className="my-class">Hello, world!</div>`.

- `cloneElement()`:
    - Используется для создания копии существующего элемента React с возможностью изменения его свойств.
    - Формат вызова: `React.cloneElement(element, [props], [...children])`.
    - `element` — это React-элемент, который вы хотите клонировать.
    - `props` — объект с новыми или измененными свойствами, которые вы хотите применить к клонированному элементу.
    - `children` — новые дочерние элементы, которые вы хотите добавить или заменить в клонированном элементе.

   ```jsx
   const element = <div className="my-class">Hello, world!</div>;
   const clonedElement = React.cloneElement(element, { className: 'new-class' });
   ```

В этом примере `clonedElement` будет `<div className="new-class">Hello, world!</div>`.

## 32. Что такое распределенный компонент?

`Распределенный компонент (или "composed component")` — это компонент, который построен из нескольких других
компонентов. Такая структура позволяет разделять функциональность на более мелкие и переиспользуемые части. Это улучшает
организацию кода, облегчает его поддержку и тестирование.

Например, вместо создания одного большого компонента, который отвечает за всё, можно создать несколько меньших
компонентов и использовать их вместе:

```jsx
// Крупный компонент
const UserProfile = () => {
    return (
        <div>
            <UserAvatar/>
            <UserName/>
            <UserBio/>
        </div>
    );
};

// Меньшие компоненты
const UserAvatar = () => <img src="avatar.jpg" alt="User Avatar"/>;
const UserName = () => <h1>John Doe</h1>;
const UserBio = () => <p>This is a user bio.</p>;
```

Преимущества распределенных компонентов:

- **Уменьшение дублирования кода**: Компонент используется в нескольких местах с разной конфигурацией.
- **Оптимизация производительности**: Компоненты загружаются только тогда, когда они действительно необходимы.
- **Упрощение управления состоянием**: Можно использовать контекст или другие подходы для передачи состояния между
  распределенными компонентами.

## 33. Как отрендерить HTML код в React-компоненте?

Можно использовать `dangerouslySetInnerHTML`, чтобы вставить HTML-код непосредственно в компонент. Это
позволяет вам рендерить HTML-код, который вы получили из внешнего источника или динамически сгенерировали. Однако, как
следует из названия, этот метод может представлять риски безопасности, такие как XSS-атаки, если HTML-код не был должным
образом очищен или проверен.

```jsx
import React from 'react';

const HtmlRenderer = ({html}) => {
    return (
        <div dangerouslySetInnerHTML={{__html: html}}/>
    );
};

export default HtmlRenderer;
```

## 34. Является ли React реактивным?

`Да`, React является реактивной библиотекой.
В контексте разработки "реактивность" означает, что пользовательский интерфейс (UI) автоматически обновляется при
изменении данных.
Это достигается благодаря использованию состояния и жизненного цикла компонентов.

Когда состояние компонента изменяется, React автоматически перерисовывает этот компонент и его дочерние компоненты,
что позволяет разработчикам сосредоточиться на логике приложения, а не на управлении обновлением интерфейса.
Эта реактивная природа делает разработку более удобной и упрощает создание сложных интерфейсов.

## 35. Что такое батчинг ререндеров?

`Батчинг` — это объединение нескольких вызовов обновления состояния в один ререндер для оптимизации.

- До React 18 батчинг был только внутри синхронных обработчиков событий.

- Начиная с React 18, батчинг работает и в асинхронных сценариях (таймауты, промисы, fetch, async/await).

`Как отменить батчинг?`

В современных версиях React (18+) отключить батчинг напрямую нельзя — он всегда включён.
Единственный «официальный» способ форсировать немедленный ререндер — использовать flushSync из react-dom:

```javascript
import { flushSync } from "react-dom";

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("init");

  const handleClick = () => {
    flushSync(() => {
      setCount((c) => c + 1); // выполнится сразу
    });
    setText("Updated!"); // это уже пойдёт в отдельный батч
  };

  return (
    <>
      <div>{count}</div>
      <div>{text}</div>
      <button onClick={handleClick}>Click</button>
    </>
  );
}
```