# Web Tech

## 1. HTTP-запросы: структура, методы, строка статуса и коды состояния

`HTTP (HyperText Transfer Protocol)` — протокол прикладного уровня, по которому клиент (браузер) и сервер обмениваются данными.

HTTP работает поверх TCP (порт 80) или TCP + TLS (в случае HTTPS — порт 443).

**TCP, TLS и HTTPS**

`TCP` — транспортный протокол, обеспечивающий надёжную и последовательную доставку данных.

Особенности TCP:

- Делит данные на пакеты и собирает обратно в правильном порядке.

- Проверяет целостность данных и пересылает утерянные пакеты.

- Гарантирует доставку без потерь и дубликатов.

HTTP, работающий поверх TCP, получает надёжную доставку, но без шифрования — данные передаются в открытом виде.

`TLS (Transport Layer Security)` — криптографический протокол, добавляющий безопасность поверх TCP. Он:

- Шифрует данные (никто не может подслушать).

- Проверяет подлинность сервера через SSL-сертификат.

- Гарантирует целостность данных при передаче.

`HTTPS = HTTP + TLS`

Работает по порту 443 и обеспечивает конфиденциальность, целостность и аутентичность данных.
Используется для форм, авторизации, API, банковских и любых защищённых сайтов.

⚡ Современный стандарт — TLS 1.3, SSL считается устаревшим.

**HTTP-запрос и ответ: структура**

HTTP-запрос и HTTP-ответ состоят из:

1. Стартовой строки

   - Запрос: GET /index.html HTTP/1.1

   - Ответ: HTTP/1.1 200 OK

2. Заголовков (Headers) — метаданные о запросе/ответе.

3. Пустой строки — разделяет заголовки и тело.

4. Тела (Body) — данные (например JSON, HTML, файл и т.д.).

**Основные методы HTTP**

| Метод | Идемпотентность | Назначение                             |
| --- | --------------- | -------------------------------------- |
| GET | ✅               | Получить данные (параметры через URL). |
| POST | ❌               | Отправить данные (формы, JSON).        |
| PUT | ✅               | Создать или заменить весь ресурс.      |
| PATCH | ❌ (частично)    | Частично обновить ресурс.              |
| DELETE | ✅               | Удалить ресурс.                        |
| HEAD | ✅               | Получить только заголовки без тела.    |
| OPTIONS | ✅               | Узнать, какие методы поддерживаются.   |


`Идемпотентность` — повторный запрос не изменяет состояние ресурса.

`Безопасные методы (safe)`: GET, HEAD, OPTIONS — не изменяют данные.

**Основные заголовки запросов**

| Заголовок | Назначение                                         |
| ------ | -------------------------------------------------- |
| Host   | Указывает домен сервера.                           |
| User-Agent | Информация о клиенте (браузере, ОС).               |
| Accept | Какие форматы клиент готов принять.                |
| Authorization | Токен или данные аутентификации.                   |
| Cookie | Отправка сохранённых данных пользователя.          |
| Content-Type | Формат тела запроса (например `application/json`). |


**Коды ответов HTTP**

| Категория | Примеры                             | Назначение                     |
| --- | ----------------------------------- |--------------------------------------|
| 1xx | 100 Continue                        | Информационные (редко используются). |
| 2xx | 200 OK, 201 Created, 204 No Content | Успешное выполнение запроса.         |
| 3xx | 301, 302, 304 Not Modified          | Перенаправления, кэширование.        |
| 4xx | 400, 401, 403, 404, 409             | Ошибки клиента.                      |
| 5xx | 500, 502, 503, 504                  | Ошибки сервера.                      |

Минимум, что должен помнить фронтендер:

- 200 — всё ок

- 201 — создано

- 204 — без содержимого

- 301 / 302 — редирект

- 304 — ресурс не изменён (используется для кэширования)

- 400 — неверный запрос

- 401 / 403 — нет доступа

- 404 — не найдено

- 409 — конфликт данных

- 500 / 502 / 503 / 504 — серверные ошибки

**HTTP/1.1 vs HTTP/2 vs HTTP/3**

| Особенность       | HTTP/1.1       | HTTP/2                    | HTTP/3 (QUIC)          |
| ----------------- | -------------- | ------------------------- | ---------------------- |
| Формат            | Текстовый      | Бинарный                  | Бинарный (на базе UDP) |
| Соединения        | Несколько TCP  | Одно мультиплексированное | Одно, на основе QUIC   |
| Сжатие заголовков | Нет            | Да (HPACK)                | Да (QPACK)             |
| Server Push       | ❌              | ✅ (устаревает)            | ❌                      |
| Безопасность      | Отдельно (TLS) | Через TLS                 | Встроено (TLS 1.3)     |
| Скорость          | Средняя        | Быстрее                   | Ещё быстрее            |

HTTP/2 — быстрее благодаря мультиплексированию и сжатию заголовков.

HTTP/3 — работает поверх QUIC (UDP), что снижает задержки и повышает стабильность при потере пакетов.

Подробнее: https://selectel.ru/blog/http-request/

## 2. Что происходит, когда вводим запрос в адресную строку браузера?

1. **Проверка кэша**

   Браузер сначала ищет ресурс в кэше:

    - Memory Cache — данные из текущей сессии.

    - Disk Cache — ранее сохранённые файлы.

    - Service Worker Cache — если сайт работает через PWA.

   Если ресурс найден и не просрочен — он загружается без запроса к серверу.

2. **DNS-резолвинг**

   Если кэша нет, браузер выполняет DNS-запрос, чтобы узнать IP-адрес домена.

   Проверяются:

    - локальный DNS-кэш,

    - DNS-провайдер,

    - при необходимости — корневые DNS-серверы.

3. **Установка соединения (TCP Handshake)**

    - Между клиентом и сервером устанавливается TCP-соединение (трёхэтапное — 3-way handshake).

4. **Установка защищённого соединения (TLS Handshake, если HTTPS)**

   Если используется HTTPS:

    - выполняется TLS Handshake поверх TCP-соединения.

    - браузер проверяет сертификат сервера (X.509) и доверяет ему, если:
   
      - он подписан надёжным удостоверяющим центром (CA).

      - срок действия не истёк.

      - домен в сертификате совпадает с запрошенным.

    - стороны договариваются о версиях протокола и алгоритмах шифрования.

    - обмениваются ключами (или параметрами для их вычисления — например, через Diffie–Hellman).

    - создаётся зашифрованный канал передачи данных.

5. **Отправка HTTP-запроса**

   Браузер отправляет HTTP-запрос (чаще всего GET) с заголовками, куками и параметрами запроса.

6. **Ответ сервера (HTTP-response)**

   Сервер возвращает HTTP-ответ:

    - Статус-код (200, 404, 500 и т.д.)

    - Заголовки

    - Тело ответа (HTML, JSON, файл и т.п.)

7. **Парсинг и рендеринг страницы**

    Браузер строит:
    
    - DOM (на основе HTML)
    
    - CSSOM (на основе CSS)
    
    - объединяет их в Render Tree,
    
    - выполняет Layout, Paint и Compositing.
    
    Параллельно подгружаются остальные ресурсы — стили, скрипты, изображения и шрифты.

8. **Отображение страницы**

   После выполнения всех этапов пользователь видит готовую страницу.

9. **Кэширование ресурсов**

   Браузер сохраняет полученные файлы в кэш (в зависимости от заголовков Cache-Control, ETag, Expires) для ускорения последующих загрузок.

## 3. Стадии работы браузера

1. **Parsing (Парсинг)**

    - Браузер получает HTML и начинает синтаксический разбор (парсинг).

    - По мере чтения HTML создаётся DOM (Document Object Model).

    - Параллельно загружаются и парсятся CSS-файлы → CSSOM (CSS Object Model).

2. **Render Tree Construction (Построение дерева рендеринга)**

    - DOM и CSSOM объединяются в Render Tree, которое содержит только видимые элементы и их стили.

    - Скрытые элементы (display: none) не включаются в Render Tree.

3. **Layout / Reflow (Расчёт размеров и позиций)**

    - На основе Render Tree браузер вычисляет размеры, положение и геометрию каждого элемента на странице.

    - Любое изменение, влияющее на размеры или структуру документа, вызывает Reflow — перерасчёт Layout.

4. **Painting (Отрисовка)**

    - Каждый элемент визуализируется: заливаются фоны, отрисовывается текст, границы, тени, изображения и т.д.

    - Изменения, не затрагивающие геометрию (например, color, background, visibility), вызывают только Repaint, без полного Reflow.

5. **Compositing (Композиция слоёв)**

    - Браузер разделяет элементы на слои (например, при использовании transform, opacity, position: fixed и т.д.).

    - Эти слои компонуются (composited) на GPU и выводятся на экран.

    - Именно на этом этапе используется аппаратное ускорение (GPU).

**Блокирующие и неблокирующие ресурсы:**

- Блокирующие:

    - CSS-файлы — блокируют рендеринг до загрузки и парсинга, так как без стилей нельзя корректно отрисовать страницу.

    - JS-файлы (без async/defer) — блокируют парсинг HTML, пока не загрузятся и не выполнятся, т.к. скрипт может изменять DOM.

- Неблокирующие:

    - Скрипты с async — загружаются параллельно и выполняются сразу после загрузки.

    - Скрипты с defer — загружаются параллельно, но выполняются после парсинга HTML (перед событием DOMContentLoaded).

    - Изображения, видео, шрифты — не блокируют DOM, но могут задерживать визуальную полноту (First Contentful Paint / Largest Contentful Paint).

**Оптимизации CRP:**

- Минимизировать количество блокирующих ресурсов.

- Критический CSS выносить инлайн в <head>.

- Загружать JS с defer или async.

- Делить код на модули (Code Splitting, lazy-loading).

- Использовать preconnect, preload, dns-prefetch для ключевых ресурсов.

- Сжимать и минимизировать файлы (gzip, brotli).

- Использовать HTTP/2 или HTTP/3 для параллельной загрузки.

- Для анимаций применять transform и opacity, чтобы избежать Reflow и Repaint.

## 4. Какие анимации лучше использовать? Преимущества transform.

1. Почему transform:

   - Аппаратное ускорение — анимации выполняются на GPU, снижая нагрузку на CPU.

   - Изменение слоя, а не DOM — transform (translate, scale, rotate) влияет только на визуальное представление, не трогая геометрию и соседние элементы.

   - Без Reflow и лишнего Paint — браузеру не нужно пересчитывать Layout и перерисовывать страницу → анимации плавные и производительные.

2. Другие безопасные свойства:

   - opacity — изменение прозрачности не вызывает Reflow, подходит для плавных переходов.

3. Что избегать:

   - Анимации свойств, влияющих на Layout: width, height, top, left, margin, padding — они вызывают Reflow и Repaint, замедляя рендеринг.

## 5. Атрибуты тега скрипт

1. `src`

    - Указывает путь к внешнему файлу скрипта (`.js`).

    - Если указан `src`, внутренний код между `<script>...</script>` игнорируется.

2. `async`

    - Загружается асинхронно и выполняется сразу после загрузки.

    - Страница продолжает парситься параллельно.

    - Порядок выполнения не гарантирован, если несколько скриптов с `async`.

    - Работает только для внешних файлов (`src`).

3. `defer`

    - Загружается параллельно, выполняется после построения DOM, перед `DOMContentLoaded`.

    - Скрипты выполняются в порядке следования в HTML.

    - Идеально для скриптов, которые взаимодействуют с DOM.

## 6. Webpack

`Webpack` — сборщик модулей (module bundler). Он объединяет JavaScript, CSS, изображения и другие ресурсы в оптимизированные файлы для ускорения загрузки и улучшения производительности.

**Основные концепции**

1. Tree Shaking

   - Удаляет неиспользуемый код из финального бандла.

   - Работает только с ES6 модулями (`import/export`).

   - Уменьшает размер бандла и ускоряет загрузку.

2. Code splitting (Чанки)

   - Разделение кода на части (chunks) для загрузки по мере необходимости.

   - Статические чанки (entry chunks): загружаются при первой загрузке приложения, формируются из точек входа (`entry`).

   - Динамические чанки (lazy-loaded): создаются при динамическом импорте модулей (`import()`), загружаются только при необходимости.

   - Позволяет сократить начальный объём кода и улучшить производительность.

3. Проксирование (dev server proxy)

   - Механизм `webpack-dev-server` для перенаправления API-запросов с фронтенда на бэкенд во время разработки.

   - Используется для обхода CORS и удобной отладки API.

   - Работает в режиме реального времени, позволяет разрабатывать/тестировать фронтенд без запуска полноценного бэкенд на другом порту.

## 7. Политика одинакового источника (same-origin policy)

`Политика одинакового источника (same-origin policy)` — механизм безопасности браузера, который ограничивает доступ скриптов одного источника к данным другого источника (origin = протокол + домен + порт).

- SOP предотвращает чтение данных или взаимодействие с DOM на другом домене напрямую.

- Пример: страница с https://example.com не может читать ответ с https://another.com/api без разрешения сервера.

## 8. CORS (Cross-Origin Resource Sharing)

`CORS (Cross-Origin Resource Sharing)` — механизм, позволяющий веб-приложению безопасно запрашивать ресурсы с другого домена.

Как работает:

1. Браузер отправляет preflight-запрос (`OPTIONS`) для “непростых” запросов, чтобы проверить, разрешает ли сервер cross-origin. 
`Непростой запрос` — это запрос, который требует preflight (OPTIONS), потому что он использует:
   - нестандартный метод (например, `PUT`, `DELETE`, `PATCH`),
   - нестандартные заголовки (например, `Authorization`, `X-Custom-Header`),
   - или `Content-Type`, отличный от `application/x-www-form-urlencoded`, `multipart/form-data` или `text/plain` (например, `application/json` делает запрос непростым).

2. Сервер отвечает заголовками:

   - `Access-Control-Allow-Origin` — домен(ы), которым разрешён доступ (* для всех).

   - `Access-Control-Allow-Methods` — список разрешённых HTTP-методов.

   - `Access-Control-Allow-Headers` — заголовки, которые клиент может отправить.

   - `Access-Control-Allow-Credentials` — разрешение отправки куки и авторизационных данных (не работает с *).

   - `Access-Control-Max-Age` — время, на которое браузер может кэшировать preflight-ответ.

   - `Access-Control-Expose-Headers` — заголовки ответа, которые JS может прочитать.

3. Если ответ удовлетворяет браузеру — выполняется основной запрос.

4. Если нет — запрос блокируется.

**Зачем нужен CORS**

- Разрешает контролируемый доступ к ресурсам с других доменов.

- Настраивается на сервере через заголовки.

- Не является полноценной защитой от CSRF/XSS — эти угрозы требуют дополнительных мер.

## 9. JWT Авторизация

`JWT (JSON Web Token)` — это открытый стандарт (RFC 7519) для безопасной передачи данных в виде JSON-объекта между клиентом и сервером, с использованием криптографической подписи. Токен состоит из трех частей, разделенных точками: заголовка, полезной нагрузки и подписи, что позволяет хранить информацию в компактном и самодостаточном формате.

Структура JWT:

- Заголовок (Header): Содержит информацию о типе токена и используемом алгоритме подписи (например, HMAC SHA256 или RSA).

- Полезная нагрузка (Payload): Содержит утверждения (claims), такие как идентификатор пользователя, роль или срок действия токена.

- Подпись (Signature): Создается на основе заголовка и полезной нагрузки с использованием секретного ключа, что обеспечивает целостность данных и подтверждает, что токен был выдан сервером.

Токены:

`Access Token` — короткоживущий (минуты–часы), используется для каждого запроса к API. Хранится в памяти приложения (React state, Redux, Context) или другом безопасном хранилище.

`Refresh Token` — долгоживущий (дни–недели), хранится в httpOnly cookie и используется только для получения нового Access Token.

Принцип работы:

1. Пользователь логинится → сервер выдаёт Access и Refresh токены.

2. Access Token отправляется с каждым запросом (заголовок Authorization).

3. Когда Access Token истекает → клиент отправляет Refresh Token на сервер → получает новый Access Token (и при необходимости новый Refresh Token).

4. Если Refresh Token истёк → пользователь разлогинивается.

Безопасность:

- Refresh Token хранится в `httpOnly` и `Secure` cookie, защищая от XSS.

- Access Token хранится в памяти или безопасном хранилище, короткий срок жизни снижает риск компрометации.

- Сервер проверяет подпись JWT и срок жизни токена.

Реализация на фронтенде:

- Axios interceptors: если запрос возвращает 401, перехватчик автоматически отправляет запрос на обновление токенов и повторяет исходный запрос.

- Таймер: декодируем поле exp → заранее обновляем Access Token.

- Redux middleware:

  - Перехватывает экшены, требующие авторизации.

  - Проверяет срок жизни Access Token перед выполнением запроса.

  - Если токен просрочен → отправляет Refresh Token на сервер, получает новый Access Token, обновляет Redux store и повторяет исходный экшен.

  - Если Refresh Token истёк → диспатчит экшен logout.

  - Можно реализовать очередь запросов, чтобы несколько параллельных запросов не запускали несколько refresh-запросов одновременно.

Особенности:

- Чтобы сервер мог корректно сетить куки, нужно указывать `withCredentials: true` в axios.

- После обновления токенов они автоматически сохраняются и используются при следующих запросах.

## 10. Методы для хранения данных в браузере?

1. `LocalStorage`

   - Хранение пар ключ-значение в строковом виде.

   - Данные сохраняются после перезагрузки страницы и даже закрытия браузера.

   - Объём: ~5–10 МБ.

   - Используется для настроек пользователя, кеширования не чувствительных данных.

2. `SessionStorage`

   - Аналогичен LocalStorage, но данные живут только в рамках одной вкладки/сессии.

   - Полезен для временных данных, которые не нужны после закрытия вкладки.

3. `Cookies`

   - Хранятся в браузере и автоматически отправляются на сервер при каждом запросе к домену.

   - Обычно используются для аутентификации и хранения небольших данных (до 4 КБ).

   - Поддерживают флаги HttpOnly, Secure, SameSite для безопасности.

4. `IndexedDB`

   - Встроенная NoSQL база данных для хранения больших объёмов данных (десятки/сотни МБ).

   - Асинхронный доступ, транзакции, индексы.

   - Отлично подходит для PWA, оффлайн-приложений, сложных структурированных данных.

## 11. Как поддерживать постоянное соединение?

1. WebSockets:

   - WebSockets позволяют установить двустороннее постоянное соединение между клиентом и сервером. Это полезно для
     приложений, требующих реального времени, таких как чаты или игры.
   - Как это работает:
     - Клиент инициирует соединение через HTTP-запрос с заголовком Upgrade.
     - Сервер принимает запрос и устанавливает постоянное соединение.
     - После установки соединения обе стороны могут отправлять данные в любое время.

    ```js
    import {useEffect, useState} from "react";
    
    const WebSocketExample = () => {
        const [messages, setMessages] = useState([]);
        const [socket, setSocket] = useState(null);
    
        useEffect(() => {
            const ws = new WebSocket("ws://example.com/socket");
            setSocket(ws);
    
            ws.onmessage = (event) => {
                setMessages((prevMessages) => [...prevMessages, event.data]);
            };
    
            return () => {
                ws.close();
            };
        }, []);
    
        return (
            <div>
                <h2>Messages</h2>
                {messages.map((msg, index) => (
                    <p key={index}>{msg}</p>
                ))}
            </div>
        );
    };
    
    export default WebSocketExample;
    ```

2. Server-Sent Events (SSE):

   - SSE — это односторонний канал, где сервер может отправлять обновления клиенту через HTTP-соединение.
   - SSE хорошо подходит для приложений, где сервер регулярно отправляет данные (например, обновления ленты новостей).

    ```js
    import {useEffect, useState} from "react";
    
    const SSEExample = () => {
        const [data, setData] = useState([]);
    
        useEffect(() => {
            const eventSource = new EventSource("http://example.com/sse");
    
            eventSource.onmessage = (event) => {
                setData((prevData) => [...prevData, event.data]);
            };
    
            return () => {
                eventSource.close();
            };
        }, []);
    
        return (
            <div>
                <h2>Data from SSE</h2>
                {data.map((item, index) => (
                    <p key={index}>{item}</p>
                ))}
            </div>
        );
    };
    
    export default SSEExample;
    ```

3. Long Polling:

   - При использовании long polling клиент отправляет запрос на сервер, сервер не отвечает сразу, а задерживает ответ
     до появления новых данных.
   - Это более старый подход по сравнению с WebSocket и SSE, но все еще может быть полезен для некоторых сценариев.

    ```js
    import {useEffect, useState} from "react";
    import axios from "axios";
    
    const LongPollingExample = () => {
        const [data, setData] = useState([]);
    
        const pollData = async () => {
            try {
                const response = await axios.get("http://example.com/long-polling");
                setData((prevData) => [...prevData, response.data]);
                pollData(); // Запрашиваем данные снова после получения ответа
            } catch (error) {
                console.error(error);
            }
        };
    
        useEffect(() => {
            pollData();
        }, []);
    
        return (
            <div>
                <h2>Data from Long Polling</h2>
                {data.map((item, index) => (
                    <p key={index}>{item}</p>
                ))}
            </div>
        );
    };
    
    export default LongPollingExample;
    ```

## 12. Архитектура проекта и ее отличие от структуры. Какие архитектуры использовал?

`Архитектура проекта` — это подход и принципы организации кода, определяющие взаимодействие между слоями приложения, ответственность модулей, способы передачи данных.
Архитектура отвечает на вопросы: _Как разделять бизнес-логику и UI? Как общаются модули? Где хранить состояние? Как расширять проект?_

`Структура проекта` — это физическая организация файлов и папок (например, папка `components/`, `pages/`, `store/`, `services/`), то есть где что лежит, но не то, как это взаимодействует.

**Feature-Sliced Design (FSD)**

  - Архитектурно: проект был разделён на слои `app`, `processes`, `pages`, `features`, `entities`, `shared`. Это помогало изолировать фичи, упрощало масштабирование и поддержку кода.

  - Структурно: каждая фича имела свою папку с компонентами, сервисами и стором. Например: `features/auth/components/`, `entities/user/store/`.

- Также использовал Redux для управления глобальным состоянием, что обеспечивало предсказуемый поток данных и упрощало дебаг.

- Для небольших проектов применял более простую структурную организацию: `components/`, `pages/`, `services/`, `store/` и т.д. без сложного деления на фичи

## 13. Что такое микрофронтенды?

`Микрофронтенды (Micro Frontends)` — это архитектурный подход, при котором крупное фронтенд-приложение делится на независимые, изолированные модули (фичи), которые могут разрабатываться, деплоиться и обновляться отдельно.

**Основные идеи:**

1. **Изоляция**: каждый модуль может использовать свой стек технологий, библиотеки и версионирование.

2. **Независимая разработка**: команды могут работать параллельно над разными частями приложения без конфликтов.

3. **Самостоятельный деплой**: каждая часть может обновляться без пересборки всего приложения.

4. **Интеграция**: микрофронтенды объединяются в единое приложение на этапе сборки, через контейнер или runtime integration (например, Webpack Module Federation, iFrames, custom elements).

**Преимущества:**

- Масштабируемость командной работы.

- Возможность использовать разные технологии для разных модулей.

- Упрощение релизов и тестирования отдельных частей.

**Недостатки:**

- Сложность интеграции и согласования стилей.

- Увеличение общего размера приложения при runtime integration.

- Требует хорошей организации деплоя и CI/CD.

## 14. Зачем нужен ESLint, настройка и плагины?

`ESLint` — это инструмент для статического анализа кода в JavaScript/TypeScript. Он проверяет код на ошибки, нарушения стиля и потенциальные баги ещё до выполнения приложения.

**Зачем нужен ESLint:**

1. **Поддержание качества кода** — помогает следовать выбранным стандартам и соглашениям по стилю.

2. **Предотвращение ошибок** — ловит синтаксические ошибки, неправильное использование переменных, потенциальные баги.

3. **Упрощение командной работы** — все разработчики следуют одним правилам, меньше конфликтов в коде.

**Настройка:**

- ESLint конфигурируется через .eslintrc (JSON, YAML или JS).

- Можно использовать базовые конфиги, например: eslint:recommended, airbnb, google.

- Правила можно включать/выключать, задавать уровни ошибок (error, warn, off).

**Плагины и расширения:**

- Плагины добавляют поддержку новых синтаксисов или библиотек, например:

  - eslint-plugin-react — проверка правил для React.

  - eslint-plugin-jsx-a11y — проверка доступности (accessibility) JSX.

  - eslint-plugin-import — проверка корректности импортов.

- Расширения (extends) позволяют быстро подключить готовые наборы правил.

**Пример использования в проекте:**

- В React-проекте: ESLint + Prettier → поддержка единообразного стиля + автоматическое форматирование кода.

## 15. Приватные вкладки (по хранилищам), отличие от обычных.

Да, я сталкивался с тестированием работы приложений в приватных вкладках браузеров. Приватный режим создаёт отдельный изолированный контейнер для всех данных текущей сессии: история, cookies, хранилища и кэш не сохраняются после закрытия окна.

**Основные отличия от обычных вкладок:**

1. Cookies и авторизация:

   - В приватном режиме cookies живут только в рамках текущей сессии.

   - После закрытия окна все cookies удаляются, поэтому при повторном открытии нужно авторизоваться заново.

   - Это полезно для тестирования логики входа/выхода и сценариев с истечением сессии.

2. LocalStorage и SessionStorage:

   - В обычном режиме localStorage хранит данные между сессиями. В приватном — данные удаляются при закрытии.

   - sessionStorage работает аналогично: живёт только в текущей вкладке.

   - Если приложение опирается на эти API, нужно учитывать, что в приватном режиме пользователь может потерять данные.

3. IndexedDB и оффлайн-функционал:

   - IndexedDB доступен, но в некоторых браузерах (например, Safari) он может быть отключён или иметь очень маленький лимит.

   - Это важно для PWA или приложений с оффлайн-режимом.

4. Service Workers и кэширование:

   - Service Workers работают, но в приватном режиме их кэш очищается после закрытия окна.

   - Это значит, что приложение не сможет полагаться на долгосрочный оффлайн-кэш.

5. Безопасность и тестирование:

   - Приватный режим полезен для проверки изоляции пользовательских данных, особенно при работе с токенами, JWT и хранением конфиденциальной информации.

   - Хорошая практика — проверять, что приложение не ломается, если хранилища недоступны или выбрасывают ошибки (QuotaExceededError в Safari).

**В React-приложениях обычно стараюсь:**

- Хранить критичные данные (например, состояние авторизации) не только в браузерных хранилищах, но и в стейте (Redux, zustand, React Query и т.д.).

- Оборачивать обращения к localStorage/IndexedDB в try-catch и иметь фолбэк (например, хранение данных только в памяти).

- Учитывать сценарии, когда приложение открыто в приватном режиме, и уведомлять пользователя об ограничениях.

Таким образом, приватные вкладки — это не просто «режим без истории», а отдельный sandbox, где данные существуют только в рамках текущей сессии. Для фронтенда это важно с точки зрения авторизации, работы с кешами и UX.

## 16. Обсерверы.

Да, приходилось работать с разными типами наблюдателей в браузере.

1. Intersection Observer

   - Использовал для ленивой подгрузки изображений и компонентов при скролле.

   - Позволяет отслеживать, когда элемент появляется или уходит из видимой области без постоянного подписывания на событие scroll, что экономит ресурсы и повышает производительность.

2. Mutation Observer

   - Применял для отслеживания изменений в DOM, например, когда сторонний скрипт добавлял или менял элементы.

   - Это безопаснее и эффективнее, чем постоянно опрашивать DOM через setInterval.

3. Resize Observer

   - Использовал для отслеживания изменения размеров элементов, чтобы динамически менять их содержимое или стиль (например, адаптивные сетки, графики).

В целом, обсерверы помогают реактивно реагировать на изменения DOM или интерфейса, снижая нагрузку на CPU и упрощая код по сравнению с ручными слушателями событий или таймерами.

## 17. Браузерное кеширование (статики, запросов, на уровне браузеров, без стейт менеджеров). Заголовки кеш контрол.

Да, я работал с браузерным кэшированием на уровне статики и HTTP-запросов.

1. Типы кэширования:

   - Кэш статики (Static Assets): изображения, шрифты, JS и CSS файлы. Браузер может хранить их локально и использовать при повторных посещениях.

   - Кэш AJAX-запросов / API: ответы GET-запросов могут кэшироваться браузером, если сервер возвращает соответствующие HTTP-заголовки.

2. Заголовки Cache-Control:

   - public / private — управляет тем, может ли кэшироваться на прокси-серверах и в браузере.

   - max-age=N — время в секундах, сколько ресурс считается свежим.

   - no-cache — браузер проверяет с сервером актуальность ресурса перед использованием.

   - no-store — запрещает хранение в кэше полностью.

   - must-revalidate — после истечения max-age ресурс должен быть проверен с сервером.

3. Другие механизмы:

   - ETag — уникальный идентификатор ресурса; браузер посылает If-None-Match и сервер отвечает 304, если ресурс не изменился.

   - Last-Modified / If-Modified-Since — похожий подход по дате последнего изменения.

4. Практика в фронтенде:

   - Для React-приложений использовал кэширование статики через service-worker (PWA), а также HTTP-заголовки на CDN.

   - Настраивал оптимальные Cache-Control для JS/CSS с версионированием файлов, чтобы при изменении контента браузер обновлял кэш.

   - При работе с API важно учитывать, что GET-запросы можно кэшировать, POST — нет, и при необходимости принудительно сбрасывать кэш через заголовки.

