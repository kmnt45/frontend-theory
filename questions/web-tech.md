# Web Tech

## 1. HTTP-запросы: структура, методы, строка статуса и коды состояния

### **Базово о протоколе HTTP**

`HTTP` (HyperText Transfer Protocol, дословно — «протокол передачи гипертекста») представляет собой протокол прикладного
уровня, используемый для доступа к ресурсам Всемирной Паутины. Под термином гипертекст следует понимать текст, в
понятном для человека представлении, при этом содержащий ссылки на другие ресурсы.

Данный протокол описывается спецификацией `RFC 2616`. На сегодняшний день наиболее распространенной версией протокола
является версия **HTTP/2**, однако нередко все еще можно встретить более раннюю версию **HTTP/1.1**.

В обмене информацией по HTTP-протоколу принимают участие клиент и сервер. Происходит это по следующей схеме:

1. Клиент запрашивает у сервера некоторый ресурс.
2. Сервер обрабатывает запрос и возвращает клиенту ресурс, который был запрошен.

![img_5.png](../assets/web-tech/img_5.png)

По умолчанию для коммуникации по HTTP используется порт 80, хотя вместо него может быть выбран и любой другой порт.
Многое зависит от конфигурации конкретного веб-сервера.

### HTTP-сообщения: запросы и ответы

Данные между клиентом и сервером в рамках работы протокола передаются с помощью HTTP-сообщений. Они бывают двух видов:

`Запросы (HTTP Requests)` — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых
действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.
`Ответы (HTTP Responses)` — сообщения, которые сервер отправляет в ответ на клиентский запрос.
Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек.

В целом, как запросы HTTP, так и ответы имеют следующую структуру:

1. `Стартовая строка (start line)` — используется для описания версии используемого протокола и другой информации —
   вроде
   запрашиваемого ресурса или кода ответа. Как можно понять из названия, ее содержимое занимает ровно одну строчку.
2. `HTTP-заголовки (HTTP Headers)` — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо
   описывают содержимое тела сообщения.
3. `Пустая строка`, которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены.
4. `Опциональное тело сообщения`, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу),
   передаваемый в ответе.

### Стартовая строка HTTP-запроса:

1. `Метод HTTP-запроса` (method, реже используется термин verb). Обычно это короткое слово на английском, которое
   указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что
   пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.
2. `Цель запроса.` Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса),
   пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров
   HTTP-запроса и еще ряд опциональных элементов.
3. `Версия используемого протокола` (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой
   строкой данных.

![img.png](../assets/web-tech/img.png)

### Методы HTTP

Методы позволяют указать конкретное действие, которое мы хотим, чтобы сервер выполнил, получив наш запрос. Так,
некоторые методы позволяют браузеру (который в большинстве случаев является источником запросов от клиента) отправлять
дополнительную информацию в теле запроса — например, заполненную форму или документ.

Ниже приведены наиболее используемые методы и их описание:

| Метод                 | Идемпотентность            | Назначение                                                                                                                                                 |
|-----------------------|----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **GET**               | Идемпотентный              | Позволяет запросить конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в URL (например, `?param=value`).     |
| **POST**              | Неидемпотентный            | Позволяет отправить данные на сервер, включая текст, PDF и другие типы файлов. Часто используется для отправки форм и загрузки данных.                     |
| **PUT**               | Идемпотентный              | Используется для создания или обновления ресурсов на сервере. Неправильная настройка может привести к проблемам безопасности.                              |
| **DELETE**            | Идемпотентный              | Позволяет удалить ресурс. Некорректное использование может вызвать отказ в обслуживании (DoS) из-за удаления важных файлов.                                |
| **HEAD**              | Идемпотентный              | Запрашивает только заголовки ресурса, как при использовании GET, но без тела ответа. Полезно для проверки размера ресурса перед загрузкой.                 |
| **OPTIONS**           | Идемпотентный              | Запрашивает информацию о сервере, включая поддерживаемые HTTP-методы.                                                                                      |
| **PATCH**             | Неидемпотентный (частично) | Позволяет внести частичные изменения в ресурс. Может считаться частично идемпотентным.                                                                     |
| **CONNECT**           | Неидемпотентный            | Создает туннель связи, например, для HTTPS через прокси. Используется для установки TLS-соединения.                                                        |
| **TRACE**             | Идемпотентный              | Выполняет обратный запрос, отображая путь запроса через промежуточные серверы. Используется для отладки, но редко разрешен из-за соображений безопасности. |
| **LINK** / **UNLINK** | Идемпотентные              | Предлагают связать или разорвать связь между ресурсами, используются в системах управления контентом и других специфических сценариях.                     |

`Идемпотентность` — это свойство операции, при котором несколько её повторных выполнений дают одинаковый результат. В
HTTP
это означает, что повторный запрос с одинаковыми параметрами не изменит состояние ресурса. Например, методы GET, PUT и
DELETE идемпотентны, потому что их повторение не приведет к разным результатам. В то время как POST и PATCH могут
изменять данные при каждом запросе, и их повторение может привести к разным результатам.

### URL

Получение доступа к ресурсам по HTTP-протоколу осуществляется с помощью указателя URL (Uniform Resource Locator). URL
представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров.

Использование URL неразрывно связано с другими элементами протокола, поэтому далее мы рассмотрим его основные компоненты
и строение:

Поле **Scheme** используется для указания используемого протокола, всегда сопровождается двоеточием и двумя косыми
чертами (://).

**Host** указывает местоположение ресурса, в нем может быть как доменное имя, так и IP-адрес.

**Port**, как можно догадаться, позволяет указать номер порта, по которому следует обратиться к серверу. Оно начинается
с
двоеточия (:), за которым следует номер порта. При отсутствии данного элемента номер порта будет выбран по умолчанию в
соответствии с указанным значением Scheme (например, для http:// это будет порт 80).

Далее следует поле **Path**. Оно указывает на ресурс, к которому производится обращение. Если данное поле не указано, то
сервер в большинстве случаев вернет указатель по умолчанию (например index.html).

Поле **Query String** начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми
расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа
амперсанд (&) в качестве разделителя.

Не все компоненты необходимы для доступа к ресурсу. Обязательно следует указать только поля **Scheme** и **Host**.

#### Версии HTTP

Последняя стабильная, наиболее стандартизированная версия протокола первого поколения (версия HTTP/1.1) вышла в далеком
1997 году. Годы шли, веб-страницы становились сложнее, некоторые из них даже стали приложениями в том виде, в котором мы
понимаем их сейчас. Кроме того, объем медиафайлов и скриптов, которые добавляли интерактивность страницам, рос. Это, в
свою очередь, создавало перегрузки в работе протокола версии HTTP/1.1.

Стало очевидно, что у HTTP/1.1 есть ряд значительных недостатков:

Заголовки, в отличие от тела сообщения, передавались в несжатом виде.
Часто большая часть заголовков в сообщениях совпадала, но они продолжали передаваться по сети.
Отсутствовала возможность так называемого мультиплексирования — механизма, позволяющего объединить несколько соединений
в один поток данных. Приходилось открывать несколько соединений на сервере для обработки входящих запросов.
С выходом HTTP/2 было предложено следующее решение: HTTP/1.X-сообщения разбивались на так называемые фреймы, которые
встраивались в поток данных.

Фреймы данных (тела сообщения) отделялись от фреймов заголовка, что позволило применять сжатие. Вместе с появлением
потоков появился и ранее описанный механизм мультиплексирования — теперь можно было обойтись одним соединением для
нескольких потоков.

Единственное о чем стоит сказать в завершение темы: HTTP/2 перестал быть текстовым протоколом, а стал работать с «сырой»
двоичной формой данных. Это ограничивает чтение и создание HTTP-сообщений «вручную». Однако такова цена за возможность
реализации более совершенной оптимизации и повышения производительности.

### Заголовки

**HTTP-заголовок** представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя.
Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в
названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного
заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну
строчку.

В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:

1. `Общего назначения`, которые применяются ко всему сообщению целиком.
2. `Заголовки запроса` уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его
   некоторыми логическими условиями.
3. `Заголовки представления`, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу
   только в тех случаях, когда с ним передается некоторое тело.

![img_1.png](../assets/web-tech/img_1.png)

| Заголовок         | Назначение                                                                                                                                                                                |
|-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Host**          | Указывает, с какого конкретно хоста запрашивается ресурс. Может содержать доменные имена или IP-адреса. Требуется для доступа к конкретному сайту на одном сервере с несколькими сайтами. |
| **User-Agent**    | Описывает клиента, запрашивающего ресурс, включая браузер, его версию и операционную систему.                                                                                             |
| **Refer**         | Указывает, откуда поступил текущий запрос. Например, если переход по ссылке происходит с другого сайта, то этот сайт будет указан в заголовке Refer.                                      |
| **Accept**        | Позволяет указать типы медиафайлов, которые принимает клиент. Несколько типов могут быть перечислены через запятую, а `*/*` означает, что клиент принимает любые типы.                    |
| **Cookie**        | Содержит пары «Куки-Значение» для идентификации и хранения пользовательских данных. Куки поддерживают сессию клиента и хранятся на стороне клиента и сервера.                             |
| **Authorization** | Используется для аутентификации клиента на сервере. После успешной аутентификации сервер возвращает токен, который хранится у клиента и отправляется по запросу.                          |

### Тело запроса

Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. Так, например,
методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. Некоторые виды запросов могут отправлять данные на
сервер в теле запроса: самый распространенный из таких методов — POST.

### **Ответы HTTP (HTTP Responses)**

**HTTP-ответ** является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна
структуре
HTTP-запроса: стартовая строка, заголовки и тело.

### Строка статуса (Status line)

Стартовая строка HTTP-ответа называется **строкой статуса (status line)**. На ней располагаются следующие элементы:

1. Уже известная нам по стартовой строке запроса `версия протокола` (HTTP/2 или HTTP/1.1).
2. `Код состояния`, который указывает, насколько успешно завершилась обработка запроса.
3. `Пояснение` — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить
   понимание
   и восприятие человека при просмотре ответа.

![img_2.png](../assets/web-tech/img_2.png)

### Коды HTTP

Коды состояния HTTP используются для того, чтобы сообщить клиенту статус их запроса. HTTP-сервер может вернуть код,
принадлежащий одной из пяти категорий кодов состояния:

| Категория | Код состояния                     | Описание                                                                                                    |
|-----------|-----------------------------------|-------------------------------------------------------------------------------------------------------------|
| **1xx**   | **Информационные**                | Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса. |
|           | 100 Continue                      | Продолжайте запрос.                                                                                         |
|           | 101 Switching Protocols           | Переключение протоколов.                                                                                    |
| **2xx**   | **Успешные**                      | Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.              |
|           | 200 OK                            | Возвращается в случае успешной обработки запроса, при этом тело ответа обычно содержит запрошенный ресурс.  |
|           | 201 Created                       | Ресурс был успешно создан.                                                                                  |
|           | 202 Accepted                      | Запрос принят, но еще не обработан.                                                                         |
|           | 203 Non-Authoritative Information | Ответ, содержащий информацию, не являющуюся авторитетной.                                                   |
|           | 204 No Content                    | Запрос выполнен, но нет содержимого для возвращения.                                                        |
|           | 205 Reset Content                 | Запрос выполнен, клиент должен сбросить представление документа.                                            |
|           | 206 Partial Content               | Сервер возвращает только часть запрашиваемого ресурса.                                                      |
| **3xx**   | **Перенаправления**               | Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.                |
|           | 300 Multiple Choices              | Несколько вариантов для ресурса.                                                                            |
|           | 301 Moved Permanently             | Ресурс был перемещен на постоянной основе.                                                                  |
|           | 302 Found                         | Перенаправляет клиента на другой URL, например, после успешной аутентификации.                              |
|           | 303 See Other                     | Необходимо получить ресурс по другому URI с использованием метода GET.                                      |
|           | 304 Not Modified                  | Запрашиваемый ресурс не изменялся с момента последнего запроса.                                             |
|           | 305 Use Proxy                     | Ресурс должен быть доступен только через прокси.                                                            |
|           | 307 Temporary Redirect            | Временное перенаправление на другой URI, используйте тот же метод.                                          |
|           | 308 Permanent Redirect            | Постоянное перенаправление на другой URI, используйте тот же метод.                                         |
| **4xx**   | **Ошибки клиента**                | Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос.                   |
|           | 400 Bad Request                   | Запрос был сформирован с ошибками, например, отсутствовали символы завершения строки.                       |
|           | 401 Unauthorized                  | Для доступа к ресурсу требуется аутентификация.                                                             |
|           | 402 Payment Required              | Зарезервировано для будущего использования (обычно для платных API).                                        |
|           | 403 Forbidden                     | Клиент не обладает достаточными правами доступа к ресурсу или обнаружены вредоносные данные.                |
|           | 404 Not Found                     | Запрашиваемый ресурс не существует на сервере.                                                              |
|           | 405 Method Not Allowed            | Метод, указанный в запросе, не разрешен для данного ресурса.                                                |
|           | 406 Not Acceptable                | Сервер не может предоставить ресурс, подходящий под условия запроса.                                        |
|           | 407 Proxy Authentication Required | Необходима аутентификация через прокси.                                                                     |
|           | 408 Request Timeout               | Время ожидания запроса истекло.                                                                             |
|           | 409 Conflict                      | Конфликт с текущим состоянием ресурса.                                                                      |
|           | 410 Gone                          | Запрашиваемый ресурс был удален и больше недоступен.                                                        |
|           | 411 Length Required               | Необходим заголовок Content-Length.                                                                         |
|           | 412 Precondition Failed           | Предусловие в заголовке запроса не выполнено.                                                               |
|           | 413 Payload Too Large             | Размер запроса превышает лимит, установленный сервером.                                                     |
|           | 414 URI Too Long                  | Запрашиваемый URI слишком длинный для обработки сервером.                                                   |
|           | 415 Unsupported Media Type        | Неподдерживаемый тип медиа в запросе.                                                                       |
|           | 416 Range Not Satisfiable         | Запрашиваемый диапазон недоступен.                                                                          |
|           | 417 Expectation Failed            | Ожидание, указанное в заголовке Expect, не было выполнено.                                                  |
| **5xx**   | **Ошибки сервера**                | Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.                         |
|           | 500 Internal Server Error         | Сервер не может обработать запрос по определенным причинам.                                                 |
|           | 501 Not Implemented               | Сервер не поддерживает функциональность, необходимую для выполнения запроса.                                |
|           | 502 Bad Gateway                   | Сервер, действующий как шлюз, получил неверный ответ от вышестоящего сервера.                               |
|           | 503 Service Unavailable           | Сервер временно недоступен, например, из-за перегрузки.                                                     |
|           | 504 Gateway Timeout               | Время ожидания ответа от вышестоящего сервера истекло.                                                      |
|           | 505 HTTP Version Not Supported    | Версия HTTP, указанная в запросе, не поддерживается сервером.                                               |

### Заголовки ответа

Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое
тела. Они существуют в том же формате, что и остальные заголовки, а именно «Имя-Значение» с двоеточием (:) в качестве
разделителя.

Ниже приведены наиболее часто встречаемые в ответах заголовки:

| Категория        | Пример                                    | Описание                                                                                                                          |
|------------------|-------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| Server           | Server: nginx                             | Содержит информацию о сервере, который обработал запрос.                                                                          |
| Set-Cookie       | Set-Cookie: PHPSSID=bf42938f              | Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов. |
| WWW-Authenticate | WWW-Authenticate: BASIC realm="localhost" | Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.                                 |

## Тело ответа

Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является
обязательным. Например, у кодов «201 Created» или «204 No Content» тело отсутствует, так как достаточную информацию для
ответа на запрос они передают в заголовке.

### Безопасность HTTP-запросов, или что такое HTTPs

**HTTP** является расширяемым протоколом, который предоставляет огромное количество возможностей, а также поддерживает
передачу всевозможных типов файлов. Однако, вне зависимости от версии, у него есть один существенный недостаток, который
можно заметить если перехватить отправленный HTTP-запрос:

![img_3.png](../assets/web-tech/img_3.png)

Да, все верно: данные передаются в открытом виде. HTTP сам по себе не предоставляет никаких средств шифрования.

Но как же тогда работают различные банковские приложения, интернет-магазины, сервисы оплаты услуг и прочие приложения, в
которых циркулирует чувствительная информация пользователей?

Время рассказать про HTTPs!

**HTTPs (HyperText Transfer Protocol, secure)** является расширением HTTP-протокола, который позволяет шифровать
отправляемые данные, перед тем как они попадут на транспортный уровень. Данный протокол по умолчанию использует порт

443.

Теперь если мы перехватим не HTTP, а HTTPs-запрос, то не увидим здесь ничего интересного:

![img_4.png](../assets/web-tech/img_4.png)

Данные передаются в едином зашифрованном потоке, что делает невозможным получение учетных данных пользователей и прочей
критической информации средствами обычного перехвата.

### Почему http-2, а не http-1 ?

HTTP/2 предпочтительнее HTTP/1.1 потому, что он позволяет мультиплексирование запросов по одному соединению, сжимает
заголовки для эффективности передачи данных и улучшает общую производительность веб-сайтов за счет бинарного формата и
приоритизации потоков.

`Минусы`

Ограниченное количество одновременных соединений:
HTTP/1.1 позволяет использовать несколько одновременных соединений для загрузки ресурсов с одного домена, но это число
ограничено (обычно 6-8 соединений). Это приводит к значительным задержкам, особенно при загрузке большого количества
ресурсов (изображений, скриптов, стилей) на современных веб-страницах.

Небольшие размеры заголовков:
В HTTP/1.x заголовки передаются в каждом запросе и ответе, что увеличивает накладные расходы, особенно при использовании
длинных куки-файлов и других данных заголовков.

Отсутствие мультиплексирования:
HTTP/1.x не поддерживает отправку нескольких запросов и ответов одновременно по одному соединению, что приводит к
блокировке при медленных запросах или больших ресурсах.

Частые разрывы соединений:
В HTTP/1.x соединения часто закрываются после завершения передачи данных, что требует повторного установления соединений
для последующих запросов, увеличивая задержки.

`Плюсы`

Бинарный протокол:
HTTP/2 использует бинарное кодирование вместо текстового в HTTP/1.x, что упрощает анализ и обработку данных, а также
снижает вероятность ошибок.

Мультиплексирование:
HTTP/2 позволяет отправлять несколько запросов и получать несколько ответов одновременно по одному TCP-соединению,
устраняя блокировку и повышая эффективность передачи данных.

Сжатие заголовков (HPACK):
HTTP/2 использует эффективное сжатие заголовков, что значительно уменьшает накладные расходы при передаче заголовков.

Приоритеты потоков:
HTTP/2 поддерживает установку приоритетов для отдельных потоков данных, что позволяет более эффективно управлять
передачей важных ресурсов.

Постоянные соединения:
HTTP/2 поддерживает длительные соединения, что уменьшает количество повторных установлений соединений и улучшает
производительность.

Серверная инициатива (Server Push):
HTTP/2 позволяет серверу отправлять ресурсы клиенту до того, как они будут запрошены, что ускоряет загрузку страниц.

Примеры преимуществ HTTP/2

Мультиплексирование:
В HTTP/1.1 каждый запрос требует отдельного соединения или использования техники keep-alive для удержания соединения
открытым, что приводит к блокировке. В HTTP/2, благодаря мультиплексированию, все ресурсы могут быть загружены
одновременно по одному соединению.

Сжатие заголовков:
Заголовки в HTTP/2 сжимаются, что особенно полезно для повторяющихся заголовков, таких как куки.

Server Push:
Сервер может отправлять необходимые ресурсы, такие как стили и скрипты, до того, как клиент их запросит, что снижает
количество запросов и улучшает время загрузки страницы.

## 2. Webpack

`Webpack` — это инструмент для сборки модулей JavaScript. Он помогает собрать различные файлы (JavaScript, CSS,
изображения и т.д.) в единый или несколько оптимизированных файлов для ускорения загрузки и улучшения производительности
приложения.

**Основные концепции Webpack:**

1. Tree Shaking — это техника оптимизации, которая удаляет неиспользуемый код из конечного бандла. В процессе сборки
   Webpack анализирует зависимости и исключает модули, которые не используются в коде. Это помогает уменьшить размер
   итогового файла и сократить время загрузки приложения.

2. Code splitting (Чанки) — это отдельные части кода, которые Webpack генерирует при сборке. Чанки могут быть динамическими и
   статическими:
   - Статические чанки (entry chunks) генерируются из точек входа (entry points), определенных в конфигурации Webpack.
     Эти чанки загружаются при начальной загрузке приложения.
   - Динамические чанки (lazy-loaded chunks) создаются при динамическом импорте модулей и загружаются только по мере
    необходимости (например, когда пользователь переходит на определенную страницу или вызывает конкретную функцию).
    Это позволяет сократить первоначальный объем кода, загружаемого на клиенте.

3. Проксирование — это механизм webpack-dev-server, который перенаправляет запросы из браузера к вашему серверу разработки (например, к API) и возвращает ответы, обрабатывая их в реальном времени.

## 3. Политика одинакового источника (same-origin policy)

`Политика одинакового источника (Same-Origin Policy)` — это механизм безопасности браузера, который ограничивает доступ скриптов, загруженных с одного источника (домен, протокол, порт), к данным с другого источника.
Она предотвращает выполнение потенциально опасных действий и защищает пользователей от XSS и CSRF атак.

**Пример:**

Страница с `https://example.com` не может напрямую читать данные с `https://another.com/api`, если сервер не настроен на это через CORS.

## 4. CORS

`CORS (Cross-Origin Resource Sharing)` — это механизм браузера, который определяет, может ли веб-приложение, загруженное с одного домена, отправлять запросы к ресурсам на другом домене.
Он работает через специальные HTTP-заголовки, которые сервер отправляет в ответ на запросы клиента.

**Как работает:**

1. Когда браузер выполняет запрос на другой домен (cross-origin), он сначала отправляет preflight-запрос с методом `OPTIONS`.

2. Сервер в ответе указывает:

   - `Access-Control-Allow-Origin` — какие домены могут делать запросы;

   - `Access-Control-Allow-Methods` — какие HTTP-методы разрешены;

   - `Access-Control-Allow-Headers` — какие заголовки можно отправлять.

3. Если ответ удовлетворяет условиям браузера, отправляется основной запрос (например, `GET` или `POST`).

4. Если заголовки не совпадают с требованиями браузера, запрос блокируется.

**Зачем нужен CORS:**

- Он предотвращает несанкционированный доступ к ресурсам с других доменов и защищает пользователей от CSRF и XSS атак.

- Разрешения на доступ явно настраиваются на сервере.

## 5. JWT Авторизация

`JWT (JSON Web Token)` — это способ аутентификации и авторизации, при котором сервер выдает клиенту токены для доступа к защищенным ресурсам. Обычно используется два токена:

`Access Token` — короткоживущий токен (несколько минут или часов), используется для каждого запроса к API.

`Refresh Token` — долгоживущий токен (несколько дней или недель), хранится в `httpOnly` cookie или другом безопасном месте и используется для обновления Access Token, когда тот истекает.

**Принцип работы:**

1. Пользователь логинится и получает пару токенов.

2. Access Token отправляется с каждым запросом (обычно в заголовке Authorization).

3. Когда Access Token истекает, клиент отправляет Refresh Token на сервер, чтобы получить новую пару токенов.

4. Если срок Refresh Token тоже истек — пользователь разлогинивается.

**Безопасность:**

- Refresh Token хранится в `httpOnly` и `Secure` cookie, чтобы его нельзя было украсть через XSS.

- Короткий срок жизни Access Token снижает риск компрометации.

**Реализация на фронтенде:**

- Через `axios interceptors`: если запрос возвращает 401, перехватчик автоматически отправляет запрос на обновление токенов и повторяет исходный запрос.

- Через таймер: можно декодировать токен (поле `exp`) и заранее обновлять его до истечения.

- Через Redux middleware: перехватчик экшенов может проверять срок действия токена перед выполнением запросов и триггерить обновление токенов.

**Особенности:**

- Чтобы сервер мог корректно сетить куки, нужно указывать `withCredentials: true` в axios.

- После обновления токенов они автоматически сохраняются и используются при следующих запросах.

## 8. Методы для хранения данных в браузере?

1. **LocalStorage**

   - Хранение пар ключ-значение в строковом виде.

   - Данные сохраняются после перезагрузки страницы и даже закрытия браузера.

   - Объём: ~5–10 МБ.

   - Используется для настроек пользователя, кеширования не чувствительных данных.

2. **SessionStorage**

   - Аналогичен LocalStorage, но данные живут только в рамках одной вкладки/сессии.

   - Полезен для временных данных, которые не нужны после закрытия вкладки.

3. **Cookies**

   - Хранятся в браузере и автоматически отправляются на сервер при каждом запросе к домену.

   - Обычно используются для аутентификации и хранения небольших данных (до 4 КБ).

   - Поддерживают флаги HttpOnly, Secure, SameSite для безопасности.

4. **IndexedDB**

   - Встроенная NoSQL база данных для хранения больших объёмов данных (десятки/сотни МБ).

   - Асинхронный доступ, транзакции, индексы.

   - Отлично подходит для PWA, оффлайн-приложений, сложных структурированных данных.

**Краткое сравнение:**

- LocalStorage / SessionStorage → простое клиентское хранение.

- Cookies → обмен данными клиент ↔ сервер.

- IndexedDB → мощное оффлайн-хранилище с большими возможностями.

## 9. Что происходит, когда вводим запрос в адресную строку браузера?

1. **Проверка кэша**

   - Сначала браузер смотрит, есть ли нужная страница в кэше (Memory Cache, Disk Cache, Service Worker).

   - Если ресурс найден и не протух — страница может загрузиться мгновенно без запросов.

2. **DNS-резолвинг**

   - Доменное имя преобразуется в IP-адрес через DNS.

   - Используются локальный кэш, DNS-сервер провайдера и корневые серверы.

3. **Установка соединения (TCP Handshake)**

   - Между клиентом и сервером устанавливается TCP-соединение (3-way handshake).

4. **TLS-шифрование (если HTTPS)**

   - Проводится TLS Handshake: проверка сертификата, обмен ключами, настройка шифрования.

5. **Отправка HTTP-запроса**

   - Браузер отправляет запрос (обычно GET) с заголовками, cookies, параметрами.

6. **Ответ сервера (HTTP-response)**

   - Сервер возвращает статус, заголовки и тело ответа (HTML, JSON и т.д.).

7. **Парсинг и рендеринг**

   - Браузер строит DOM, CSSOM, выполняет JS, собирает Render Tree, делает Layout, Paint и Compositing.

   - Дополнительно подгружаются ресурсы (CSS, JS, картинки) параллельно.

8. **Отображение страницы**

   - После выполнения всех этапов пользователь видит готовую страницу.

9. **Кэширование ресурсов**

   - Браузер сохраняет файлы в кэш для ускорения повторных загрузок.

## 10. Стадии работы браузера

1. **Parsing (Парсинг)**

   - Браузер загружает HTML и CSS.

   - Создаёт DOM (Document Object Model) из HTML и CSSOM (CSS Object Model) из CSS.

2. **Render Tree Construction (Построение дерева рендеринга)**

   - DOM и CSSOM объединяются в Render Tree, которое содержит только видимые элементы и их стили.

3. **Layout / Reflow (Расчёт)**

   - Рассчитываются размеры, положение и геометрия всех элементов.

   - Любое изменение, влияющее на размеры или структуру документа, вызывает Reflow.

4. **Painting (Перерисовка)**

   - Рендерятся цвета, текстуры, границы, фоновые изображения и другие визуальные свойства элементов.

   - Изменения, не влияющие на геометрию, могут вызвать только Repaint (без Reflow).

5. **Compositing (Композиция слоёв)**

   - Финальный этап: слои складываются и отрисовываются на экране.

   - Здесь происходит аппаратное ускорение (GPU).

**Блокирующие и неблокирующие ресурсы:**

  - Блокирующие:

    - CSS-файлы — блокируют рендеринг до их загрузки и обработки.

    - JS-файлы (без async/defer) — блокируют парсинг HTML, пока не загрузятся и не выполнятся.

  - Неблокирующие:

    - Скрипты с атрибутами async (загружаются параллельно и выполняются сразу по готовности) и defer (загружаются параллельно, выполняются после парсинга HTML).

    - Изображения, шрифты, видео — не блокируют построение DOM, но могут задерживать визуальную полноту.

**Оптимизации CRP:**

- Минимизировать количество блокирующих ресурсов (выносить CSS в критический инлайн, а JS грузить с defer).

- Разбивать CSS и JS на модули (Code Splitting, lazy-loading).

- Использовать preconnect/preload для ключевых ресурсов.

- Сжимать и минимизировать файлы, использовать HTTP/2.

- Использование transform и opacity для анимаций.

**Короткий ответ:**

После построения DOM, CSSOM и Render Tree начинается рендеринг.
Layout (Reflow) отвечает за расчёт размеров и позиций всех элементов. Если меняются размеры, нужно пересчитать часть или всё дерево.
Paint — это отрисовка всех визуальных свойств: цветов, границ, теней. Paint может происходить без Layout, если геометрия не изменилась.
Compositing собирает готовые слои на GPU, что позволяет анимировать свойства вроде transform и opacity без Reflow и Repaint.
То есть Layout — это “расчёт”, Paint — “рисование”, Compositing — “сборка слоёв”.

## 11. Как поддерживать постоянное соединение?

1. **WebSockets:**

   - WebSockets позволяют установить двустороннее постоянное соединение между клиентом и сервером. Это полезно для
     приложений, требующих реального времени, таких как чаты или игры.
   - Как это работает:
     - Клиент инициирует соединение через HTTP-запрос с заголовком Upgrade.
     - Сервер принимает запрос и устанавливает постоянное соединение.
     - После установки соединения обе стороны могут отправлять данные в любое время.

**Пример с использованием WebSocket в React:**

```js
import {useEffect, useState} from "react";

const WebSocketExample = () => {
    const [messages, setMessages] = useState([]);
    const [socket, setSocket] = useState(null);

    useEffect(() => {
        const ws = new WebSocket("ws://example.com/socket");
        setSocket(ws);

        ws.onmessage = (event) => {
            setMessages((prevMessages) => [...prevMessages, event.data]);
        };

        return () => {
            ws.close();
        };
    }, []);

    return (
        <div>
            <h2>Messages</h2>
            {messages.map((msg, index) => (
                <p key={index}>{msg}</p>
            ))}
        </div>
    );
};

export default WebSocketExample;
```

2. **Server-Sent Events (SSE):**

   - SSE — это односторонний канал, где сервер может отправлять обновления клиенту через HTTP-соединение.
   - SSE хорошо подходит для приложений, где сервер регулярно отправляет данные (например, обновления ленты новостей).

**Пример с использованием SSE в React:**

```js
import {useEffect, useState} from "react";

const SSEExample = () => {
    const [data, setData] = useState([]);

    useEffect(() => {
        const eventSource = new EventSource("http://example.com/sse");

        eventSource.onmessage = (event) => {
            setData((prevData) => [...prevData, event.data]);
        };

        return () => {
            eventSource.close();
        };
    }, []);

    return (
        <div>
            <h2>Data from SSE</h2>
            {data.map((item, index) => (
                <p key={index}>{item}</p>
            ))}
        </div>
    );
};

export default SSEExample;
```

3. **Long Polling:**

   - При использовании long polling клиент отправляет запрос на сервер, сервер не отвечает сразу, а задерживает ответ
     до появления новых данных.
   - Это более старый подход по сравнению с WebSocket и SSE, но все еще может быть полезен для некоторых сценариев.

**Пример с использованием long polling:**

```js
import {useEffect, useState} from "react";
import axios from "axios";

const LongPollingExample = () => {
    const [data, setData] = useState([]);

    const pollData = async () => {
        try {
            const response = await axios.get("http://example.com/long-polling");
            setData((prevData) => [...prevData, response.data]);
            pollData(); // Запрашиваем данные снова после получения ответа
        } catch (error) {
            console.error(error);
        }
    };

    useEffect(() => {
        pollData();
    }, []);

    return (
        <div>
            <h2>Data from Long Polling</h2>
            {data.map((item, index) => (
                <p key={index}>{item}</p>
            ))}
        </div>
    );
};

export default LongPollingExample;
```

**Какой из подходов выбрать?**

- WebSocket — лучший выбор для приложений с интенсивным обменом данными в реальном времени (чаты, онлайн-игры).

- SSE — для приложений, где сервер отправляет обновления данных (ленты новостей, уведомления).

- Long Polling — используется реже, но может быть полезен там, где WebSocket или SSE не поддерживаются.

## 12. Архитектура проекта и ее отличие от структуры. Какие архитектуры использовал?

**Разница между архитектурой и структурой:**

- **Архитектура проекта** — это подход и принципы организации кода, определяющие взаимодействие между слоями приложения, ответственность модулей, способы передачи данных.
Архитектура отвечает на вопросы: _Как разделять бизнес-логику и UI? Как общаются модули? Где хранить состояние? Как расширять проект?_

- **Структура проекта** — это физическая организация файлов и папок (например, папка `components/`, `pages/`, `store/`, `services/`), то есть где что лежит, но не то, как это взаимодействует.

**Мой опыт:**

- На предыдущем проекте я работал с Feature-Sliced Design (FSD):

  - **Архитектурно**: проект был разделён на слои `app`, `processes`, `pages`, `features`, `entities`, `shared`. Это помогало изолировать фичи, упрощало масштабирование и поддержку кода.

  - **Структурно**: каждая фича имела свою папку с компонентами, сервисами и стором. Например: `features/auth/components/`, `entities/user/store/`.

- Также использовал Redux для управления глобальным состоянием, что обеспечивало предсказуемый поток данных и упрощало дебаг.

- Для небольших проектов применял более простую структурную организацию: `components/`, `pages/`, `services/`, `store/` без сложного деления на фичи.

**Нужно дополнять**

## 13. Что такое микрофронтенды?

`Микрофронтенды (Micro Frontends)` — это архитектурный подход, при котором крупное фронтенд-приложение делится на независимые, изолированные модули (фичи), которые могут разрабатываться, деплоиться и обновляться отдельно.

**Основные идеи:**

1. **Изоляция**: каждый модуль может использовать свой стек технологий, библиотеки и версионирование.

2. **Независимая разработка**: команды могут работать параллельно над разными частями приложения без конфликтов.

3. **Самостоятельный деплой**: каждая часть может обновляться без пересборки всего приложения.

4. **Интеграция**: микрофронтенды объединяются в единое приложение на этапе сборки, через контейнер или runtime integration (например, Webpack Module Federation, iFrames, custom elements).

**Преимущества:**

- Масштабируемость командной работы.

- Возможность использовать разные технологии для разных модулей.

- Упрощение релизов и тестирования отдельных частей.

**Недостатки:**

- Сложность интеграции и согласования стилей.

- Увеличение общего размера приложения при runtime integration.

- Требует хорошей организации деплоя и CI/CD.

## 14. Зачем нужен ESLint, настройка и плагины?

`ESLint` — это инструмент для статического анализа кода в JavaScript/TypeScript. Он проверяет код на ошибки, нарушения стиля и потенциальные баги ещё до выполнения приложения.

**Зачем нужен ESLint:**

1. **Поддержание качества кода** — помогает следовать выбранным стандартам и соглашениям по стилю.

2. **Предотвращение ошибок** — ловит синтаксические ошибки, неправильное использование переменных, потенциальные баги.

3. **Упрощение командной работы** — все разработчики следуют одним правилам, меньше конфликтов в коде.

**Настройка:**

- ESLint конфигурируется через .eslintrc (JSON, YAML или JS).

- Можно использовать базовые конфиги, например: eslint:recommended, airbnb, google.

- Правила можно включать/выключать, задавать уровни ошибок (error, warn, off).

**Плагины и расширения:**

- Плагины добавляют поддержку новых синтаксисов или библиотек, например:

  - eslint-plugin-react — проверка правил для React.

  - eslint-plugin-jsx-a11y — проверка доступности (accessibility) JSX.

  - eslint-plugin-import — проверка корректности импортов.

- Расширения (extends) позволяют быстро подключить готовые наборы правил.

**Пример использования в проекте:**

- В React-проекте: ESLint + Prettier → поддержка единообразного стиля + автоматическое форматирование кода.

## 15. Приходилось ли работать с приватными вкладками (по хранилищам), отличие от обычных?

Да, я сталкивался с тестированием работы приложений в приватных вкладках браузеров. Приватный режим создаёт отдельный изолированный контейнер для всех данных текущей сессии: история, cookies, хранилища и кэш не сохраняются после закрытия окна.

**Основные отличия от обычных вкладок:**

1. Cookies и авторизация:

   - В приватном режиме cookies живут только в рамках текущей сессии.

   - После закрытия окна все cookies удаляются, поэтому при повторном открытии нужно авторизоваться заново.

   - Это полезно для тестирования логики входа/выхода и сценариев с истечением сессии.

2. LocalStorage и SessionStorage:

   - В обычном режиме localStorage хранит данные между сессиями. В приватном — данные удаляются при закрытии.

   - sessionStorage работает аналогично: живёт только в текущей вкладке.

   - Если приложение опирается на эти API, нужно учитывать, что в приватном режиме пользователь может потерять данные.

3. IndexedDB и оффлайн-функционал:

   - IndexedDB доступен, но в некоторых браузерах (например, Safari) он может быть отключён или иметь очень маленький лимит.

   - Это важно для PWA или приложений с оффлайн-режимом.

4. Service Workers и кэширование:

   - Service Workers работают, но в приватном режиме их кэш очищается после закрытия окна.

   - Это значит, что приложение не сможет полагаться на долгосрочный оффлайн-кэш.

5. Безопасность и тестирование:

   - Приватный режим полезен для проверки изоляции пользовательских данных, особенно при работе с токенами, JWT и хранением конфиденциальной информации.

   - Хорошая практика — проверять, что приложение не ломается, если хранилища недоступны или выбрасывают ошибки (QuotaExceededError в Safari).

**В React-приложениях обычно стараюсь:**

- Хранить критичные данные (например, состояние авторизации) не только в браузерных хранилищах, но и в стейте (Redux, zustand, React Query и т.д.).

- Оборачивать обращения к localStorage/IndexedDB в try-catch и иметь фолбэк (например, хранение данных только в памяти).

- Учитывать сценарии, когда приложение открыто в приватном режиме, и уведомлять пользователя об ограничениях.

Таким образом, приватные вкладки — это не просто «режим без истории», а отдельный sandbox, где данные существуют только в рамках текущей сессии. Для фронтенда это важно с точки зрения авторизации, работы с кешами и UX.

## 16. Приходилось ли работать с обсерверами какими-нибудь?

Да, приходилось работать с разными типами наблюдателей в браузере.

1. Intersection Observer

   - Использовал для ленивой подгрузки изображений и компонентов при скролле.

   - Позволяет отслеживать, когда элемент появляется или уходит из видимой области без постоянного подписывания на событие scroll, что экономит ресурсы и повышает производительность.

2. Mutation Observer

   - Применял для отслеживания изменений в DOM, например, когда сторонний скрипт добавлял или менял элементы.

   - Это безопаснее и эффективнее, чем постоянно опрашивать DOM через setInterval.

3. Resize Observer

   - Использовал для отслеживания изменения размеров элементов, чтобы динамически менять их содержимое или стиль (например, адаптивные сетки, графики).

В целом, обсерверы помогают реактивно реагировать на изменения DOM или интерфейса, снижая нагрузку на CPU и упрощая код по сравнению с ручными слушателями событий или таймерами.

## 17. Рассказать про браузерное кеширование(статики, запросов, на уровне браузеров, без стейт менеджеров), слышал ли про заголовки кеш контрол?

Да, я работал с браузерным кэшированием на уровне статики и HTTP-запросов.

1. Типы кэширования:

   - Кэш статики (Static Assets): изображения, шрифты, JS и CSS файлы. Браузер может хранить их локально и использовать при повторных посещениях.

   - Кэш AJAX-запросов / API: ответы GET-запросов могут кэшироваться браузером, если сервер возвращает соответствующие HTTP-заголовки.

2. Заголовки Cache-Control:

   - public / private — управляет тем, может ли кэшироваться на прокси-серверах и в браузере.

   - max-age=N — время в секундах, сколько ресурс считается свежим.

   - no-cache — браузер проверяет с сервером актуальность ресурса перед использованием.

   - no-store — запрещает хранение в кэше полностью.

   - must-revalidate — после истечения max-age ресурс должен быть проверен с сервером.

3. Другие механизмы:

   - ETag — уникальный идентификатор ресурса; браузер посылает If-None-Match и сервер отвечает 304, если ресурс не изменился.

   - Last-Modified / If-Modified-Since — похожий подход по дате последнего изменения.

4. Практика в фронтенде:

   - Для React-приложений использовал кэширование статики через service-worker (PWA), а также HTTP-заголовки на CDN.

   - Настраивал оптимальные Cache-Control для JS/CSS с версионированием файлов, чтобы при изменении контента браузер обновлял кэш.

   - При работе с API важно учитывать, что GET-запросы можно кэшировать, POST — нет, и при необходимости принудительно сбрасывать кэш через заголовки.

