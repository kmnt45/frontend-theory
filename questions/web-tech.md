# Web Tech

## 1. HTTP-запросы: структура, методы, строка статуса и коды состояния

`HTTP (HyperText Transfer Protocol)` — протокол прикладного уровня, по которому клиент (браузер) и сервер обмениваются данными.

Работает поверх TCP (порт 80) или TLS (в случае HTTPS — порт 443).

`TCP` — это транспортный протокол, обеспечивающий надёжную и последовательную передачу данных между клиентом и сервером.
HTTP использует TCP как «транспорт», по которому движутся его сообщения.

Основные особенности TCP:

- Делит данные на пакеты и собирает обратно в правильном порядке.

- Проверяет целостность данных и пересылает утерянные пакеты.

- Гарантирует доставку данных без потерь и дубликатов.

HTTP, работающий поверх TCP, получает от него надёжную доставку, но без шифрования — все данные передаются в открытом виде.

`TLS` — это криптографический протокол, который добавляет безопасность поверх TCP.
HTTP, работающий через TLS, называется HTTPS.

Что делает TLS:

- Шифрует данные — никто не может подслушать передаваемое.

- Проверяет подлинность сервера (через SSL-сертификат).

- Гарантирует целостность данных — они не могут быть изменены по пути.

HTTPS = HTTP + TLS (или устаревший SSL)
Работает по порту 443.
Используется для всех сайтов, где важны безопасность и конфиденциальность (банки, формы, авторизация, API).

HTTP-запрос и HTTP-ответ состоят из:

- Стартовой строки — метод (или код ответа), путь, версия протокола.

- Заголовков (Headers) — метаданные о запросе или ответе.

- Пустой строки.

- Тела (Body) — содержимое (например JSON, HTML, файл).

Методы HTTP: 

| Метод       | Идемпотентность | Назначение                             |
| ----------- | --------------- | -------------------------------------- |
| **GET**     | ✅               | Получить данные (параметры через URL). |
| **POST**    | ❌               | Отправить данные (формы, JSON).        |
| **PUT**     | ✅               | Создать или заменить ресурс.           |
| **PATCH**   | ❌ (частично)    | Частичное обновление ресурса.          |
| **DELETE**  | ✅               | Удалить ресурс.                        |
| **HEAD**    | ✅               | Только заголовки (без тела).           |
| **OPTIONS** | ✅               | Узнать, какие методы поддерживаются.   |

`Идемпотентность` — повторный вызов не меняет состояние (GET, PUT, DELETE).

Основные заголовки запроса:

| Заголовок         | Назначение                                         |
| ----------------- | -------------------------------------------------- |
| **Host**          | Указывает сервер (домен).                          |
| **User-Agent**    | Данные о браузере.                                 |
| **Accept**        | Какие форматы клиент готов принять.                |
| **Authorization** | Токен или данные аутентификации.                   |
| **Cookie**        | Отправка сохранённых данных пользователя.          |
| **Content-Type**  | Формат тела запроса (например `application/json`). |

Коды ответов (самое важное):

| Категория | Примеры                             | Смысл                                  |
| --------- | ----------------------------------- | -------------------------------------- |
| **1xx**   | 100                                 | Информационные. Почти не используются. |
| **2xx**   | 200 OK, 201 Created, 204 No Content | Успешно.                               |
| **3xx**   | 301, 302, 304                       | Перенаправления.                       |
| **4xx**   | 400, 401, 403, 404, 409             | Ошибки клиента.                        |
| **5xx**   | 500, 502, 503                       | Ошибки сервера.                        |

Минимум, что должен помнить фронтенд:

- 200 — всё ок

- 201 — создано

- 204 — без содержимого

- 301/302 — редирект

- 400 — неверный запрос

- 401/403 — нет доступа

- 404 — не найдено

- 500/502/503 — серверные ошибки

HTTPS

HTTPs = HTTP + шифрование (TLS/SSL).
Все данные передаются зашифрованно.
Используется порт 443.
Гарантирует конфиденциальность, целостность и аутентичность.

HTTP/1.1 vs HTTP/2

| Особенность | HTTP/1.1      | HTTP/2                    |
| ----------- | ------------- | ------------------------- |
| Формат      | Текстовый     | Бинарный                  |
| Соединения  | Несколько TCP | Одно мультиплексированное |
| Заголовки   | Без сжатия    | Сжатие (HPACK)            |
| Server Push | ❌             | ✅                         |
| Скорость    | Медленнее     | Быстрее и эффективнее     |

HTTP/2 быстрее, потому что позволяет отправлять несколько запросов по одному соединению и сжимает заголовки.

Подробнее: https://selectel.ru/blog/http-request/

## 2. Что происходит, когда вводим запрос в адресную строку браузера?

1. **Проверка кэша**

   Браузер сначала ищет ресурс в кэше:

    - Memory Cache — данные из текущей сессии.

    - Disk Cache — ранее сохранённые файлы.

    - Service Worker Cache — если сайт работает через PWA.

   Если ресурс найден и не просрочен — он загружается без запроса к серверу.

2. **DNS-резолвинг**

   Если кэша нет, браузер выполняет DNS-запрос, чтобы узнать IP-адрес домена.

   Проверяются:

    - локальный DNS-кэш,

    - DNS-провайдер,

    - при необходимости — корневые DNS-серверы.

3. **Установка соединения (TCP Handshake)**

    - Между клиентом и сервером устанавливается TCP-соединение (3-way handshake).

4. **TLS-шифрование (если HTTPS)**

   Если используется HTTPS:

    - происходит TLS Handshake,

    - браузер проверяет SSL-сертификат сервера,

    - стороны обмениваются ключами шифрования и создают защищённый канал.

5. **Отправка HTTP-запроса**

   Браузер отправляет HTTP-запрос (чаще всего GET) с заголовками, куками и параметрами запроса.

6. **Ответ сервера (HTTP-response)**

   Сервер возвращает HTTP-ответ:

    - Статус-код (200, 404, 500 и т.д.)

    - Заголовки

    - Тело ответа (HTML, JSON, файл и т.п.)

7. **Парсинг и рендеринг страницы**

   Браузер строит DOM, CSSOM, выполняет JS, собирает Render Tree, делает Layout, Paint и Compositing.

   Параллельно подгружаются остальные ресурсы (CSS, JS, изображения).

8. **Отображение страницы**

   После выполнения всех этапов пользователь видит готовую страницу.

9. **Кэширование ресурсов**

   Браузер сохраняет файлы в кэш для ускорения повторных загрузок.

## 3. Стадии работы браузера

1. **Parsing (Парсинг)**

    - Браузер получает HTML и начинает синтаксический разбор (парсинг).

    - По мере чтения HTML создаётся DOM (Document Object Model).

    - Параллельно загружаются и парсятся CSS-файлы → CSSOM (CSS Object Model).

2. **Render Tree Construction (Построение дерева рендеринга)**

    - DOM и CSSOM объединяются в Render Tree, которое содержит только видимые элементы и их стили.

    - Скрытые элементы (display: none) не включаются в Render Tree.

3. **Layout / Reflow (Расчёт размеров и позиций)**

    - На основе Render Tree браузер вычисляет размеры, положение и геометрию каждого элемента на странице.

    - Любое изменение, влияющее на размеры или структуру документа, вызывает Reflow — перерасчёт Layout.

4. **Painting (Отрисовка)**

    - Каждый элемент визуализируется: заливаются фоны, отрисовывается текст, границы, тени, изображения и т.д.

    - Изменения, не затрагивающие геометрию (например, color, background, visibility), вызывают только Repaint, без полного Reflow.

5. **Compositing (Композиция слоёв)**

    - Браузер разделяет элементы на слои (например, при использовании transform, opacity, position: fixed и т.д.).

    - Эти слои компонуются (composited) на GPU и выводятся на экран.

    - Именно на этом этапе используется аппаратное ускорение (GPU).

**Блокирующие и неблокирующие ресурсы:**

- Блокирующие:

    - CSS-файлы — блокируют рендеринг до загрузки и парсинга, так как без стилей нельзя корректно отрисовать страницу.

    - JS-файлы (без async/defer) — блокируют парсинг HTML, пока не загрузятся и не выполнятся, т.к. скрипт может изменять DOM.

- Неблокирующие:

    - Скрипты с async — загружаются параллельно и выполняются сразу после загрузки.

    - Скрипты с defer — загружаются параллельно, но выполняются после парсинга HTML (перед событием DOMContentLoaded).

    - Изображения, видео, шрифты — не блокируют DOM, но могут задерживать визуальную полноту (First Contentful Paint / Largest Contentful Paint).

**Оптимизации CRP:**

- Минимизировать количество блокирующих ресурсов.

- Критический CSS выносить инлайн в <head>.

- Загружать JS с defer или async.

- Делить код на модули (Code Splitting, lazy-loading).

- Использовать preconnect, preload, dns-prefetch для ключевых ресурсов.

- Сжимать и минимизировать файлы (gzip, brotli).

- Использовать HTTP/2 или HTTP/3 для параллельной загрузки.

- Для анимаций применять transform и opacity, чтобы избежать Reflow и Repaint.

## 4. Какие анимации лучше использовать? Преимущества transform.

1. **Почему transform:**

    - **Аппаратное ускорение**: анимации выполняются на GPU, что снижает нагрузку на CPU.

    - **Изменение слоя, а не DOM**: transform (translate, scale, rotate) меняет только визуальное отображение элемента, не влияя на его размеры или положение других элементов.

    - **Избегание Reflow и Paint**: браузеру не нужно пересчитывать расположение элементов и рендерить заново весь документ → плавные и производительные анимации.

2. **Другие безопасные свойства:**

    - **opacity** — изменение прозрачности элемента тоже не триггерит Reflow и Paint, подходит для плавных анимаций.

**Вывод:**

- Для плавных, высокопроизводительных анимаций лучше использовать transform + opacity.

- Избегать анимаций свойств типа width, height, top, left, которые вызывают тяжелые Reflow/Render.

Свойства transform и opacity не меняют геометрию элемента, поэтому Reflow не происходит. Если элемент вынесен в отдельный слой, их анимация обрабатывается на этапе Compositing без Repaint. В худшем случае будет только Repaint, но не пересчёт Layout. Поэтому мы используем transform/opacity для плавных анимаций.

## 5. Атрибуты тега скрипт

1. `src`

    - Указывает путь к внешнему файлу скрипта (`.js`).

    - Если указан src, внутренний код между `<script>...</script>` писать не нужно.

2. `async`

    - Скрипт загружается асинхронно и запускается сразу после загрузки, не дожидаясь построения страницы.

    - Страница продолжает загружаться параллельно.

    - Работает только для внешних файлов (`src`).

3. `defer`

    - Скрипт загружается параллельно, но запускается только после полной загрузки страницы (DOM построен).

    - Хорошо подходит для скриптов, которые взаимодействуют с DOM.

## 6. Webpack

`Webpack` — это инструмент для сборки модулей JavaScript. Он помогает собрать различные файлы (JavaScript, CSS,
изображения и т.д.) в единый или несколько оптимизированных файлов для ускорения загрузки и улучшения производительности
приложения.

**Основные концепции Webpack:**

1. `Tree Shaking` — это техника оптимизации, которая удаляет неиспользуемый код из конечного бандла. В процессе сборки
   Webpack анализирует зависимости и исключает модули, которые не используются в коде. Это помогает уменьшить размер
   итогового файла и сократить время загрузки приложения.

2. `Code splitting (Чанки)` — это отдельные части кода, которые Webpack генерирует при сборке. Чанки могут быть динамическими и
   статическими:
   - Статические чанки (entry chunks) генерируются из точек входа (entry points), определенных в конфигурации Webpack.
     Эти чанки загружаются при начальной загрузке приложения.
   - Динамические чанки (lazy-loaded chunks) создаются при динамическом импорте модулей и загружаются только по мере
    необходимости (например, когда пользователь переходит на определенную страницу или вызывает конкретную функцию).
    Это позволяет сократить первоначальный объем кода, загружаемого на клиенте.

3. `Проксирование` — это механизм webpack-dev-server, который перенаправляет запросы из браузера к вашему серверу разработки (например, к API) и возвращает ответы, обрабатывая их в реальном времени.

## 7. Политика одинакового источника (same-origin policy)

`Политика одинакового источника (Same-Origin Policy)` — это механизм безопасности браузера, который ограничивает доступ скриптов, загруженных с одного источника (домен, протокол, порт), к данным с другого источника.
Она предотвращает выполнение потенциально опасных действий и защищает пользователей от XSS и CSRF атак.

**Пример:**

Страница с `https://example.com` не может напрямую читать данные с `https://another.com/api`, если сервер не настроен на это через CORS.

## 8. CORS

`CORS (Cross-Origin Resource Sharing)` — это механизм браузера, который определяет, может ли веб-приложение, загруженное с одного домена, отправлять запросы к ресурсам на другом домене.
Он работает через специальные HTTP-заголовки, которые сервер отправляет в ответ на запросы клиента.

**Как работает:**

1. Когда браузер выполняет запрос на другой домен (cross-origin), он сначала отправляет preflight-запрос с методом `OPTIONS`.

2. Сервер в ответе указывает:

   - `Access-Control-Allow-Origin` — какие домены могут делать запросы;

   - `Access-Control-Allow-Methods` — какие HTTP-методы разрешены;

   - `Access-Control-Allow-Headers` — какие заголовки можно отправлять.

3. Если ответ удовлетворяет условиям браузера, отправляется основной запрос (например, `GET` или `POST`).

4. Если заголовки не совпадают с требованиями браузера, запрос блокируется.

**Зачем нужен CORS:**

- Он предотвращает несанкционированный доступ к ресурсам с других доменов и защищает пользователей от CSRF и XSS атак.

- Разрешения на доступ явно настраиваются на сервере.

## 9. JWT Авторизация

`JWT (JSON Web Token)` — это способ аутентификации и авторизации, при котором сервер выдает клиенту токены для доступа к защищенным ресурсам. Обычно используется два токена:

`Access Token` — короткоживущий токен (несколько минут или часов), используется для каждого запроса к API.

`Refresh Token` — долгоживущий токен (несколько дней или недель), хранится в `httpOnly` cookie или другом безопасном месте и используется для обновления Access Token, когда тот истекает.

**Принцип работы:**

1. Пользователь логинится и получает пару токенов.

2. Access Token отправляется с каждым запросом (обычно в заголовке Authorization).

3. Когда Access Token истекает, клиент отправляет Refresh Token на сервер, чтобы получить новую пару токенов.

4. Если срок Refresh Token тоже истек — пользователь разлогинивается.

**Безопасность:**

- Refresh Token хранится в `httpOnly` и `Secure` cookie, чтобы его нельзя было украсть через XSS.

- Короткий срок жизни Access Token снижает риск компрометации.

**Реализация на фронтенде:**

- Через `axios interceptors`: если запрос возвращает 401, перехватчик автоматически отправляет запрос на обновление токенов и повторяет исходный запрос.

- Через таймер: можно декодировать токен (поле `exp`) и заранее обновлять его до истечения.

- Через Redux middleware: перехватчик экшенов может проверять срок действия токена перед выполнением запросов и триггерить обновление токенов.

**Особенности:**

- Чтобы сервер мог корректно сетить куки, нужно указывать `withCredentials: true` в axios.

- После обновления токенов они автоматически сохраняются и используются при следующих запросах.

## 10. Методы для хранения данных в браузере?

1. **LocalStorage**

   - Хранение пар ключ-значение в строковом виде.

   - Данные сохраняются после перезагрузки страницы и даже закрытия браузера.

   - Объём: ~5–10 МБ.

   - Используется для настроек пользователя, кеширования не чувствительных данных.

2. **SessionStorage**

   - Аналогичен LocalStorage, но данные живут только в рамках одной вкладки/сессии.

   - Полезен для временных данных, которые не нужны после закрытия вкладки.

3. **Cookies**

   - Хранятся в браузере и автоматически отправляются на сервер при каждом запросе к домену.

   - Обычно используются для аутентификации и хранения небольших данных (до 4 КБ).

   - Поддерживают флаги HttpOnly, Secure, SameSite для безопасности.

4. **IndexedDB**

   - Встроенная NoSQL база данных для хранения больших объёмов данных (десятки/сотни МБ).

   - Асинхронный доступ, транзакции, индексы.

   - Отлично подходит для PWA, оффлайн-приложений, сложных структурированных данных.

**Краткое сравнение:**

- LocalStorage / SessionStorage → простое клиентское хранение.

- Cookies → обмен данными клиент ↔ сервер.

- IndexedDB → мощное оффлайн-хранилище с большими возможностями.

## 11. Как поддерживать постоянное соединение?

1. **WebSockets:**

   - WebSockets позволяют установить двустороннее постоянное соединение между клиентом и сервером. Это полезно для
     приложений, требующих реального времени, таких как чаты или игры.
   - Как это работает:
     - Клиент инициирует соединение через HTTP-запрос с заголовком Upgrade.
     - Сервер принимает запрос и устанавливает постоянное соединение.
     - После установки соединения обе стороны могут отправлять данные в любое время.

**Пример с использованием WebSocket в React:**

```js
import {useEffect, useState} from "react";

const WebSocketExample = () => {
    const [messages, setMessages] = useState([]);
    const [socket, setSocket] = useState(null);

    useEffect(() => {
        const ws = new WebSocket("ws://example.com/socket");
        setSocket(ws);

        ws.onmessage = (event) => {
            setMessages((prevMessages) => [...prevMessages, event.data]);
        };

        return () => {
            ws.close();
        };
    }, []);

    return (
        <div>
            <h2>Messages</h2>
            {messages.map((msg, index) => (
                <p key={index}>{msg}</p>
            ))}
        </div>
    );
};

export default WebSocketExample;
```

2. **Server-Sent Events (SSE):**

   - SSE — это односторонний канал, где сервер может отправлять обновления клиенту через HTTP-соединение.
   - SSE хорошо подходит для приложений, где сервер регулярно отправляет данные (например, обновления ленты новостей).

**Пример с использованием SSE в React:**

```js
import {useEffect, useState} from "react";

const SSEExample = () => {
    const [data, setData] = useState([]);

    useEffect(() => {
        const eventSource = new EventSource("http://example.com/sse");

        eventSource.onmessage = (event) => {
            setData((prevData) => [...prevData, event.data]);
        };

        return () => {
            eventSource.close();
        };
    }, []);

    return (
        <div>
            <h2>Data from SSE</h2>
            {data.map((item, index) => (
                <p key={index}>{item}</p>
            ))}
        </div>
    );
};

export default SSEExample;
```

3. **Long Polling:**

   - При использовании long polling клиент отправляет запрос на сервер, сервер не отвечает сразу, а задерживает ответ
     до появления новых данных.
   - Это более старый подход по сравнению с WebSocket и SSE, но все еще может быть полезен для некоторых сценариев.

**Пример с использованием long polling:**

```js
import {useEffect, useState} from "react";
import axios from "axios";

const LongPollingExample = () => {
    const [data, setData] = useState([]);

    const pollData = async () => {
        try {
            const response = await axios.get("http://example.com/long-polling");
            setData((prevData) => [...prevData, response.data]);
            pollData(); // Запрашиваем данные снова после получения ответа
        } catch (error) {
            console.error(error);
        }
    };

    useEffect(() => {
        pollData();
    }, []);

    return (
        <div>
            <h2>Data from Long Polling</h2>
            {data.map((item, index) => (
                <p key={index}>{item}</p>
            ))}
        </div>
    );
};

export default LongPollingExample;
```

**Какой из подходов выбрать?**

- WebSocket — лучший выбор для приложений с интенсивным обменом данными в реальном времени (чаты, онлайн-игры).

- SSE — для приложений, где сервер отправляет обновления данных (ленты новостей, уведомления).

- Long Polling — используется реже, но может быть полезен там, где WebSocket или SSE не поддерживаются.

## 12. Архитектура проекта и ее отличие от структуры. Какие архитектуры использовал?

**Разница между архитектурой и структурой:**

- **Архитектура проекта** — это подход и принципы организации кода, определяющие взаимодействие между слоями приложения, ответственность модулей, способы передачи данных.
Архитектура отвечает на вопросы: _Как разделять бизнес-логику и UI? Как общаются модули? Где хранить состояние? Как расширять проект?_

- **Структура проекта** — это физическая организация файлов и папок (например, папка `components/`, `pages/`, `store/`, `services/`), то есть где что лежит, но не то, как это взаимодействует.

**Мой опыт:**

- На предыдущем проекте я работал с Feature-Sliced Design (FSD):

  - **Архитектурно**: проект был разделён на слои `app`, `processes`, `pages`, `features`, `entities`, `shared`. Это помогало изолировать фичи, упрощало масштабирование и поддержку кода.

  - **Структурно**: каждая фича имела свою папку с компонентами, сервисами и стором. Например: `features/auth/components/`, `entities/user/store/`.

- Также использовал Redux для управления глобальным состоянием, что обеспечивало предсказуемый поток данных и упрощало дебаг.

- Для небольших проектов применял более простую структурную организацию: `components/`, `pages/`, `services/`, `store/` без сложного деления на фичи.

**Нужно дополнять**

## 13. Что такое микрофронтенды?

`Микрофронтенды (Micro Frontends)` — это архитектурный подход, при котором крупное фронтенд-приложение делится на независимые, изолированные модули (фичи), которые могут разрабатываться, деплоиться и обновляться отдельно.

**Основные идеи:**

1. **Изоляция**: каждый модуль может использовать свой стек технологий, библиотеки и версионирование.

2. **Независимая разработка**: команды могут работать параллельно над разными частями приложения без конфликтов.

3. **Самостоятельный деплой**: каждая часть может обновляться без пересборки всего приложения.

4. **Интеграция**: микрофронтенды объединяются в единое приложение на этапе сборки, через контейнер или runtime integration (например, Webpack Module Federation, iFrames, custom elements).

**Преимущества:**

- Масштабируемость командной работы.

- Возможность использовать разные технологии для разных модулей.

- Упрощение релизов и тестирования отдельных частей.

**Недостатки:**

- Сложность интеграции и согласования стилей.

- Увеличение общего размера приложения при runtime integration.

- Требует хорошей организации деплоя и CI/CD.

## 14. Зачем нужен ESLint, настройка и плагины?

`ESLint` — это инструмент для статического анализа кода в JavaScript/TypeScript. Он проверяет код на ошибки, нарушения стиля и потенциальные баги ещё до выполнения приложения.

**Зачем нужен ESLint:**

1. **Поддержание качества кода** — помогает следовать выбранным стандартам и соглашениям по стилю.

2. **Предотвращение ошибок** — ловит синтаксические ошибки, неправильное использование переменных, потенциальные баги.

3. **Упрощение командной работы** — все разработчики следуют одним правилам, меньше конфликтов в коде.

**Настройка:**

- ESLint конфигурируется через .eslintrc (JSON, YAML или JS).

- Можно использовать базовые конфиги, например: eslint:recommended, airbnb, google.

- Правила можно включать/выключать, задавать уровни ошибок (error, warn, off).

**Плагины и расширения:**

- Плагины добавляют поддержку новых синтаксисов или библиотек, например:

  - eslint-plugin-react — проверка правил для React.

  - eslint-plugin-jsx-a11y — проверка доступности (accessibility) JSX.

  - eslint-plugin-import — проверка корректности импортов.

- Расширения (extends) позволяют быстро подключить готовые наборы правил.

**Пример использования в проекте:**

- В React-проекте: ESLint + Prettier → поддержка единообразного стиля + автоматическое форматирование кода.

## 15. Приватные вкладки (по хранилищам), отличие от обычных.

Да, я сталкивался с тестированием работы приложений в приватных вкладках браузеров. Приватный режим создаёт отдельный изолированный контейнер для всех данных текущей сессии: история, cookies, хранилища и кэш не сохраняются после закрытия окна.

**Основные отличия от обычных вкладок:**

1. Cookies и авторизация:

   - В приватном режиме cookies живут только в рамках текущей сессии.

   - После закрытия окна все cookies удаляются, поэтому при повторном открытии нужно авторизоваться заново.

   - Это полезно для тестирования логики входа/выхода и сценариев с истечением сессии.

2. LocalStorage и SessionStorage:

   - В обычном режиме localStorage хранит данные между сессиями. В приватном — данные удаляются при закрытии.

   - sessionStorage работает аналогично: живёт только в текущей вкладке.

   - Если приложение опирается на эти API, нужно учитывать, что в приватном режиме пользователь может потерять данные.

3. IndexedDB и оффлайн-функционал:

   - IndexedDB доступен, но в некоторых браузерах (например, Safari) он может быть отключён или иметь очень маленький лимит.

   - Это важно для PWA или приложений с оффлайн-режимом.

4. Service Workers и кэширование:

   - Service Workers работают, но в приватном режиме их кэш очищается после закрытия окна.

   - Это значит, что приложение не сможет полагаться на долгосрочный оффлайн-кэш.

5. Безопасность и тестирование:

   - Приватный режим полезен для проверки изоляции пользовательских данных, особенно при работе с токенами, JWT и хранением конфиденциальной информации.

   - Хорошая практика — проверять, что приложение не ломается, если хранилища недоступны или выбрасывают ошибки (QuotaExceededError в Safari).

**В React-приложениях обычно стараюсь:**

- Хранить критичные данные (например, состояние авторизации) не только в браузерных хранилищах, но и в стейте (Redux, zustand, React Query и т.д.).

- Оборачивать обращения к localStorage/IndexedDB в try-catch и иметь фолбэк (например, хранение данных только в памяти).

- Учитывать сценарии, когда приложение открыто в приватном режиме, и уведомлять пользователя об ограничениях.

Таким образом, приватные вкладки — это не просто «режим без истории», а отдельный sandbox, где данные существуют только в рамках текущей сессии. Для фронтенда это важно с точки зрения авторизации, работы с кешами и UX.

## 16. Обсерверы.

Да, приходилось работать с разными типами наблюдателей в браузере.

1. Intersection Observer

   - Использовал для ленивой подгрузки изображений и компонентов при скролле.

   - Позволяет отслеживать, когда элемент появляется или уходит из видимой области без постоянного подписывания на событие scroll, что экономит ресурсы и повышает производительность.

2. Mutation Observer

   - Применял для отслеживания изменений в DOM, например, когда сторонний скрипт добавлял или менял элементы.

   - Это безопаснее и эффективнее, чем постоянно опрашивать DOM через setInterval.

3. Resize Observer

   - Использовал для отслеживания изменения размеров элементов, чтобы динамически менять их содержимое или стиль (например, адаптивные сетки, графики).

В целом, обсерверы помогают реактивно реагировать на изменения DOM или интерфейса, снижая нагрузку на CPU и упрощая код по сравнению с ручными слушателями событий или таймерами.

## 17. Браузерное кеширование (статики, запросов, на уровне браузеров, без стейт менеджеров). Заголовки кеш контрол.

Да, я работал с браузерным кэшированием на уровне статики и HTTP-запросов.

1. Типы кэширования:

   - Кэш статики (Static Assets): изображения, шрифты, JS и CSS файлы. Браузер может хранить их локально и использовать при повторных посещениях.

   - Кэш AJAX-запросов / API: ответы GET-запросов могут кэшироваться браузером, если сервер возвращает соответствующие HTTP-заголовки.

2. Заголовки Cache-Control:

   - public / private — управляет тем, может ли кэшироваться на прокси-серверах и в браузере.

   - max-age=N — время в секундах, сколько ресурс считается свежим.

   - no-cache — браузер проверяет с сервером актуальность ресурса перед использованием.

   - no-store — запрещает хранение в кэше полностью.

   - must-revalidate — после истечения max-age ресурс должен быть проверен с сервером.

3. Другие механизмы:

   - ETag — уникальный идентификатор ресурса; браузер посылает If-None-Match и сервер отвечает 304, если ресурс не изменился.

   - Last-Modified / If-Modified-Since — похожий подход по дате последнего изменения.

4. Практика в фронтенде:

   - Для React-приложений использовал кэширование статики через service-worker (PWA), а также HTTP-заголовки на CDN.

   - Настраивал оптимальные Cache-Control для JS/CSS с версионированием файлов, чтобы при изменении контента браузер обновлял кэш.

   - При работе с API важно учитывать, что GET-запросы можно кэшировать, POST — нет, и при необходимости принудительно сбрасывать кэш через заголовки.

